<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>极大似然估计</title>
      <link href="/2023/08/18/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/"/>
      <url>/2023/08/18/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="似然和极大似然估计"><a href="#似然和极大似然估计" class="headerlink" title="似然和极大似然估计"></a>似然和极大似然估计</h1><p>为了深入讨论似然的概念，我们需要先来了解概率和似然。<br>概率和似然都是统计学中的重要概念，他们之间有着紧密的联系。</p><h2 id="概率和似然"><a href="#概率和似然" class="headerlink" title="概率和似然"></a>概率和似然</h2><h3 id="概率的概念"><a href="#概率的概念" class="headerlink" title="概率的概念"></a>概率的概念</h3><p>概率是在特定环境下，某件事情发生的可能性。  </p><p>在结果没有产生之前，我们可以根据环境中的参数，对某件事情发生的概率进行预测。</p><h4 id="举例-概率事件"><a href="#举例-概率事件" class="headerlink" title="举例: 概率事件"></a>举例: 概率事件</h4><p>对于抛硬币事件，在抛硬币之前并不知道，抛硬币的结果是哪一面朝上。<br>但我们可以根据硬币的性质进行推测。<br>如果抛掷的硬币是一枚均匀的硬币，那么可以推断出，任何一面朝上的可能性都是50%。  </p><p>我们要注意，这里的概率50%，只有在抛硬币之前是有意义的，因为抛完硬币后，结果就确定了。</p><p><img src="/img/blog/Maximum_Likelihood_Estimate/抛硬币概率.png" alt="抛硬币概率"></p><h3 id="似然的概念"><a href="#似然的概念" class="headerlink" title="似然的概念"></a>似然的概念</h3><p>似然和概率刚好相反，它是基于已经确定的结果来推测产生这个结果的可能环境，或者是推测环境中的某些参数。</p><h4 id="举例-似然事件"><a href="#举例-似然事件" class="headerlink" title="举例: 似然事件"></a>举例: 似然事件</h4><p>在抛硬币的例子，假如随机抛出一枚硬币1万次，结果8000次人像在上，2000次数字在上。那么可以判断出，这枚硬币在构造时是有些特殊的。<br>我们基于抛掷结果，进一步推测该硬币的具体参数，人像的概率是0.8，数字的概率是0.2。</p><p>这个根据结果判断事情本身性质的过程，就是似然。<br><img src="/img/blog/Maximum_Likelihood_Estimate/抛硬币似然.png" alt="抛硬币似然"></p><p>因此，总结来说，似然和概率可以看作是问题的两个不同方向。<br>概率是在已知模型参数的情况下预测结果，而似然是在已知结果的情况下推断模型参数。</p><h2 id="概率与似然的数学表示"><a href="#概率与似然的数学表示" class="headerlink" title="概率与似然的数学表示"></a>概率与似然的数学表示</h2><p>θ: 环境中的参数<br>x: 事件发生的结果</p><p>概率: P(x|θ)，已知θ，计算x的发生概率<br>似然: L(θ|x)，已知x，推断参数θ</p><p>P(x|θ)是关于x的函数，L(θ|x)是关于θ的函数</p><h2 id="极大似然估计-Maximum-Likelihood-Estimate"><a href="#极大似然估计-Maximum-Likelihood-Estimate" class="headerlink" title="极大似然估计(Maximum Likelihood Estimate)"></a>极大似然估计(Maximum Likelihood Estimate)</h2><p>利用已知的样本标记结果，反推最具有可能，或者最大概率导致这些样本结果出现的模型参数。</p><p>极大似然估计是一种已知观察数据来推断模型参数的过程。<br>例如，根据事件x的观察结果，推断θ是多少时，结果x最有可能发生，就是极大似然估计。</p><h3 id="举例-极大似然估计事件"><a href="#举例-极大似然估计事件" class="headerlink" title="举例: 极大似然估计事件"></a>举例: 极大似然估计事件</h3><p>仍然使用抛硬币这个例子。<br>设它有θ的概率人像在上，那么就有1-θ的概率数字在上。<br>θ是客观存在的，但是我们最初并不知道θ具体是多少，需要根据观测结果进行推断。</p><p>为了获得θ，需要进行多次抛硬币实验，并记录抛出的结果序列。<br>假如在这个序列中，有7次是人像，3次是数字。<br>这样就得到了函数L(θ)等于θ的7次方乘1减θ的3次方。<br><img src="/img/blog/Maximum_Likelihood_Estimate/抛硬币极大似然估计.png" alt="抛硬币极大似然估计"></p><h2 id="似然函数的图像"><a href="#似然函数的图像" class="headerlink" title="似然函数的图像"></a>似然函数的图像</h2><p>函数L被称为θ的似然函数。<br>对于函数L(θ)，我们可以枚举θ的值，画出函数L的图像。<br>当θ等于0时，函数值是0，等于0.5时，函数是1024分之1等等。<br>这时我们会发现，函数在θ等于0.7时，取得最大值。<br><img src="/img/blog/Maximum_Likelihood_Estimate/似然函数.png" alt="抛硬币极大似然估计"></p><h2 id="极大似然估计的假设条件"><a href="#极大似然估计的假设条件" class="headerlink" title="极大似然估计的假设条件"></a>极大似然估计的假设条件</h2><p>当我们使用极大似然估计来估计参数时，我们需要满足一些假设条件：</p><ol><li><p>独立性假设：观测数据之间是相互独立的，即每个观测结果不会受到其他观测结果的影响。</p></li><li><p>同分布假设：观测数据是来自同一个分布，即每个观测结果都是从同一个概率分布中独立地抽取得到的。</p></li><li><p>参数空间假设：参数空间是一个可数集合，其中包含了可能的参数取值。</p></li></ol><h2 id="极大似然估计的注意事项"><a href="#极大似然估计的注意事项" class="headerlink" title="极大似然估计的注意事项"></a>极大似然估计的注意事项</h2><p>当使用极大似然估计来估计参数时，我们需要注意以下几点：</p><ol><li><p>数据的合理性：在进行极大似然估计之前，需要确保观测数据是合理的，并符合所假设的概率分布。如果数据不符合假设的分布，那么使用极大似然估计可能会导致不准确的结果。</p></li><li><p>参数空间的限制：在估计参数时，需要确定参数空间的范围。参数空间的选择可能会影响估计结果。如果参数空间选择不当，可能会导致估计结果不准确或不可靠。</p></li><li><p>估计结果的可靠性：极大似然估计得到的参数估计值并不一定是准确的，它是在给定观测数据的情况下，最可能产生这个观测数据的参数值。因此，需要考虑估计结果的可靠性。可以通过计算置信区间或进行假设检验来评估参数估计的显著性。</p></li><li><p>模型选择：极大似然估计通常是在给定一个概率模型的情况下进行的。但是，在实际应用中，我们可能需要选择合适的概率模型。选择合适的模型对于得到准确的参数估计非常重要。</p></li><li><p>数据量的影响：极大似然估计的准确性通常随着数据量的增加而增加。更多的数据可以提供更多的信息，从而得到更准确的参数估计。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>极大似然估计是一种参数估计方法，它的目标是找到最可能产生观察数据结果的参数值。  </p><p>在机器学习算法中，比如逻辑回归模型，会根据已有的数据X，学习相应的参数分布，也就是计算θ，这其实就是极大似然估计的思想。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hugging Face入门 (模型文件详解)</title>
      <link href="/2023/08/11/Hugging%20Face%E5%85%A5%E9%97%A84/"/>
      <url>/2023/08/11/Hugging%20Face%E5%85%A5%E9%97%A84/</url>
      
        <content type="html"><![CDATA[<h1 id="Hugging-Face入门-模型文件详解"><a href="#Hugging-Face入门-模型文件详解" class="headerlink" title="Hugging Face入门 (模型文件详解)"></a>Hugging Face入门 (模型文件详解)</h1><h1 id="Hugging-face-Llama-2-模型文件详解"><a href="#Hugging-face-Llama-2-模型文件详解" class="headerlink" title="Hugging face Llama-2 模型文件详解"></a>Hugging face Llama-2 模型文件详解</h1><p>当使用 AutoClass 或者 pipeline() 进行模型加载时，我们会看到从Hugging face上下载模型相关文件。<br>这些文件有什么作用？今天我们就以模型 meta-llama/Llama-2-7b-chat-hf 为例，介绍模型的文件组成。</p><h2 id="模型文件详解"><a href="#模型文件详解" class="headerlink" title="模型文件详解"></a>模型文件详解</h2><p>Llama-2 Huggingface 文件构成如下图所示：</p><p><img src="/img/blog/huggingface4/Llma2_hugging_face.png" alt="Llma2_hugging_face"></p><h3 id="Huggingface-文件介绍"><a href="#Huggingface-文件介绍" class="headerlink" title="Huggingface 文件介绍"></a>Huggingface 文件介绍</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>描述</th></tr></thead><tbody><tr><td>config.json</td><td>模型的主要配置信息，如 Bert 模型设置、预测头部设置、训练参数等</td></tr><tr><td>generation_config.json</td><td>文本生成相关的模型配置</td></tr><tr><td>model-00001-of-00002.safetensors</td><td>safetensors 文件格式的模型权重参数的分块</td></tr><tr><td>model-00002-of-00002.safetensors</td><td>safetensors 文件格式的模型权重参数的分块</td></tr><tr><td>model.safetensors.index.json</td><td>safetensors 模型参数文件的索引，描述了模型切片的信息</td></tr><tr><td>pytorch_model-00001-of-00002.bin</td><td>pickle 序列化的 PyTorch 模型权重参数的分块</td></tr><tr><td>pytorch_model-00002-of-00002.bin</td><td>pickle 序列化的 PyTorch 模型权重参数的分块</td></tr><tr><td>pytorch_model.bin.index.json</td><td>pickle 序列化的 PyTorch 模型索引，描述了模型切片的信息</td></tr><tr><td>special_tokens_map.json</td><td>tokenizer 中特殊标记符（special tokens）到数字 ID 的映射关系</td></tr><tr><td>tokenizer.json</td><td>tokenizer 的配置信息，如字典大小、tokenize 策略等</td></tr><tr><td>tokenizer.model</td><td>tokenizer 的具体模型参数，经过训练得到的二进制文件</td></tr><tr><td>tokenizer_config.json</td><td>使用该 tokenizer 时的配置，如最大序列长度等</td></tr></tbody></table></div><h3 id="模型切片的索引信息"><a href="#模型切片的索引信息" class="headerlink" title="模型切片的索引信息"></a>模型切片的索引信息</h3><p>一个完整的大型模型通常会被切分成多个碎片（shards），并以 <code>model-00001-of-00002.safetensors</code> 这种命名方式保存。<br><code>pytorch_model.bin.index.json</code> 文件包含所有的模型切片信息，主要包括：</p><ul><li><p>模型切片的总数。</p></li><li><p>每个切片的元数据，如名称、偏移地址、文件大小等。</p></li><li><p>切片如何组合起来重新组成完整模型的说明。</p></li><li><p>一些额外的模型信息，如模型名称、框架版本等元数据。</p></li></ul><h3 id="Tokenizer-特殊标记符（Special-Tokens）"><a href="#Tokenizer-特殊标记符（Special-Tokens）" class="headerlink" title="Tokenizer 特殊标记符（Special Tokens）"></a>Tokenizer 特殊标记符（Special Tokens）</h3><p><code>special_tokens_map.json</code> 包含 Tokenizer 特殊标记符（Special Tokens）到其对应的数字 ID 的映射。</p><p>一些常见的特殊标记符定义包括：</p><ul><li><p><code>unk_token</code>：未登录词（out-of-vocabulary words）的标记 ID。</p></li><li><p><code>sep_token</code>：句子分隔的标记 ID。</p></li><li><p><code>pad_token</code>：填充序列到相等长度时使用的填充标记 ID。</p></li><li><p><code>cls_token</code>：分类任务中使用的分类标记 ID。</p></li><li><p><code>mask_token</code>：掩码语言模型任务中使用的掩码标记 ID。</p></li></ul><h3 id="safetensors-文件"><a href="#safetensors-文件" class="headerlink" title="safetensors 文件"></a>safetensors 文件</h3><p>safetensors 是一种安全快速存储和加载 tensors 的文件格式。<br>通常，PyTorch 模型权重会使用 Python 的 pickle 工具将数据序列化到一个 .bin 文件中。<br>然而，pickle 不安全，pickle 的文件可能包含可以执行的恶意代码。safetensors 是 pickle 的一个安全替代方案，非常适合共享模型权重。</p><p>有关使用 Safetensors 的详细信息，请参考 <a href="https://huggingface.co/docs/diffusers/main/en/using-diffusers/using_safetensors">Using Safetensors</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hugging Face </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hugging Face入门 (Pipeline)</title>
      <link href="/2023/08/08/Hugging%20Face%E5%85%A5%E9%97%A83/"/>
      <url>/2023/08/08/Hugging%20Face%E5%85%A5%E9%97%A83/</url>
      
        <content type="html"><![CDATA[<h1 id="Hugging-Face入门-Pipeline"><a href="#Hugging-Face入门-Pipeline" class="headerlink" title="Hugging Face入门 (Pipeline)"></a>Hugging Face入门 (Pipeline)</h1><p>Pipeline是使用模型进行推理的一种非常方便和简单的方式。Pipeline将库中大部分复杂的代码进行了封装，提供了一个专门用于多个任务的简单API，包括命名实体识别、掩码语言建模、情感分析、特征提取和问答等任务。</p><p>Transformers库为Pipeline提供了一个方便的接口函数<code>pipeline()</code>来支持这些特性。可以在<a href="https://huggingface.co/docs/transformers/v4.31.0/en/main_classes/pipelines#pipelines">huggingface文档</a>上了解更多关于Pipeline的详细信息。</p><p>接下来，我们将学习如何使用<code>pipeline()</code>函数。</p><h2 id="安装transformers和sentencepiece库"><a href="#安装transformers和sentencepiece库" class="headerlink" title="安装transformers和sentencepiece库"></a>安装transformers和sentencepiece库</h2><p>使用以下命令来安装<code>transformers</code>和<code>sentencepiece</code>库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install git+https://github.com/huggingface/transformers sentencepiece --quiet</span><br></pre></td></tr></table></figure><h2 id="文本摘要的示例"><a href="#文本摘要的示例" class="headerlink" title="文本摘要的示例"></a>文本摘要的示例</h2><p>每种任务类型都有相应的Pipeline类，但是使用通用的<code>pipeline()</code>函数更加简单，该函数可以自动加载默认模型，或者指定模型，并提供了对您的任务进行推理的预处理。<br>例如，对于文本摘要任务，我们可以使用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline() 函数需要设置2个参数，第一个是任务类型，第二个是模型名称。</span></span><br><span class="line"><span class="comment"># 没有设置第一个参数的原因，pipeline能自动识别模型是做summarization任务，并加载该类型到模型中</span></span><br><span class="line">generator = pipeline(model=<span class="string">&quot;knkarthick/MEETING_SUMMARY&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(generator.__class__)</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;transformers.pipelines.text2text_generation.SummarizationPipeline&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>通过将文本加载到摘要生成器（generator），我们可以轻松地生成一段文本的摘要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">London, the capital of England and the United Kingdom, is a 21st-century city with history stretching back to Roman times. At its centre stand the imposing Houses of Parliament, the iconic ‘Big Ben’ clock tower and Westminster Abbey, site of British monarch coronations. Across the Thames River, the London Eye observation wheel provides panoramic views of the South Bank cultural complex, and the entire city.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">generator(text)</span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&#x27;summary_text&#x27;</span>: <span class="string">&#x27;The London Eye offers panoramic views of the South Bank and the entire city.&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="图像识别的示例"><a href="#图像识别的示例" class="headerlink" title="图像识别的示例"></a>图像识别的示例</h2><p>Transformers还支持图像识别任务，可以使用pipelines提供的功能非常简单地对图像进行识别。<br>以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"></span><br><span class="line">classifier = pipeline(model=<span class="string">&quot;google/vit-base-patch16-224&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classifier.__class__)</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;transformers.pipelines.image_classification.ImageClassificationPipeline&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>通过将图片url加载到图片分类器（classifier），我们可以轻松地完成图片识别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">image_url = <span class="string">&quot;https://huggingface.co/datasets/Narsil/image_dummy/raw/main/parrots.png&quot;</span></span><br><span class="line">classifier(image_url)</span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&#x27;score&#x27;</span>: <span class="number">0.9905232787132263</span>, <span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;macaw&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;score&#x27;</span>: <span class="number">0.005603468045592308</span>, <span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;African grey, African gray, Psittacus erithacus&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;score&#x27;</span>: <span class="number">0.0010569051373749971</span>, <span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;toucan&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;score&#x27;</span>: <span class="number">0.0006811480852775276</span>, <span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;score&#x27;</span>: <span class="number">0.0006714325281791389</span>, <span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;lorikeet&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用pipeline对图像进行识别，并打印了每个标签及其对应的分数。</p><h2 id="Pipeline函数的参数"><a href="#Pipeline函数的参数" class="headerlink" title="Pipeline函数的参数"></a>Pipeline函数的参数</h2><p>除了任务类型（task）和模型名称（model）参数之外，<code>pipeline()</code>函数还支持一系列通用的模型参数和特定的任务参数。</p><p>以下是一些重要的通用模型参数的介绍：</p><ul><li><code>device</code>：此参数用于指定模型推理所在的设备。<br>  在huggingface transformers的pipeline函数中，device参数也可以设置为一个整数，比如0，是为了将模型加载到特定编号的 GPU 进行推理。<br>  <code>device</code> 参数可以设置的值：<ul><li><code>&quot;cpu&quot;</code>：将模型加载到CPU上进行推理。</li><li><code>&quot;cuda&quot;</code>：将模型加载到第一块GPU上进行推理，等同于<code>&quot;cuda:0&quot;</code>。</li><li><code>&quot;cuda:X&quot;</code>：将模型加载到编号为X的GPU上进行推理，其中X是GPU的编号。</li><li><code>&quot;mps&quot;</code>： 将模型加载到Mac OS上的Apple M1或M2芯片上利用Metal Performance Shaders (MPS) 进行推理。</li><li><code>&quot;tpu&quot;</code>： 将模型加载到Tensor Processing Unit (TPU) 上进行推理,如Google Colab中的TPU。</li><li><code>&quot;auto&quot;</code>： 自动选择一个可用的设备，会按优先级首先选择TPU，然后是GPU，最后是CPU。  </li></ul></li></ul><ul><li><code>batch_size</code>: 默认情况下，pipeline不会做批量推理（batch inference）。但是，pipeline函数提供了batch_size参数支持批量推理。可以将<code>batch_size</code>设置为一个正整数来指定批量推理的大小。例如，<code>batch_size=4</code>将会将输入分为大小为4的批次进行推理。<br><code>batch_size</code> 参数会影响到:<ul><li><code>&quot;推理速度&quot;</code>：增加batch_size通常可以提高GPU利用效率，加速推理速度。但若过大也会导致OOM。</li><li><code>&quot;内存占用&quot;</code>：较大的batch_size会占用更多GPU显存。</li><li><code>&quot;推理效果&quot;</code>：某些模型对batch_size比较敏感,大小不同会影响准确率。</li><li><code>&quot;支持长度&quot;</code>：一些模型对最大输入长度有限制,batch_size过大可能超出模型支持长度。</li><li><code>&quot;输出&quot;</code>：输出会是一个批量结果列表,如果只需要单条结果,需要索引获取。</li></ul></li></ul><ul><li><code>truncation</code>: 控制输入文本的截断方式。<br>  <code>truncation</code> 参数可以设置的值：<ul><li><code>&quot;do_not_truncate&quot;</code>: 不截断输入文本。</li><li><code>&quot;longest_first&quot;</code>: 从最长的句子开始截断。</li><li><code>&quot;only_first&quot;</code>: 只截断第一个句子。</li><li><code>&quot;only_second&quot;</code>: 只截断第二个句子。</li><li><code>&quot;longest_second&quot;</code>: 从最长的第二个句子开始截断。</li></ul></li></ul><ul><li><code>padding</code>: 控制输入文本的填充方式。<br>  <code>padding</code> 参数可以设置的值：<ul><li><code>&quot;do_not_pad&quot;</code>: 不填充输入文本。</li><li><code>&quot;longest&quot;</code>: 使用最长的句子进行填充。</li><li><code>&quot;max_length&quot;</code>: 使用指定的<code>max_length</code>参数进行填充。</li></ul></li></ul><h2 id="模型特有的参数"><a href="#模型特有的参数" class="headerlink" title="模型特有的参数"></a>模型特有的参数</h2><p>除了上述模型通用的参数之外，不同的任务类型还有一些特定的参数。<br>例如，在文本分类任务中，<code>TextClassificationPipeline</code>类具有一个特定的参数<code>return_all_scores</code>，用于控制是否返回所有预测分数或只返回预测命中类别的分数。  </p><p>以下是一个使用<code>TextClassificationPipeline</code>类的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line">classifier = pipeline(model=<span class="string">&quot;ProsusAI/finbert&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(classifier.__class__)</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;transformers.pipelines.text_classification.TextClassificationPipeline&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Hundreds of new North Sea oil and gas licences to boost British energy independence and grow the economy</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">classifier(sentence, return_all_scores=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">[[&#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;positive&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">0.886681854724884</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;negative&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">0.009547530673444271</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&#x27;neutral&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">0.10377060621976852</span>&#125;]]</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>return_all_scores</code>参数设置为<code>True</code>，因此返回了所有预测分数。如果将其设置为<code>False</code>，则只会返回预测命中类别的分数。<br>TextClassificationPipeline详细参数设置，可以参考文档<a href="https://huggingface.co/docs/transformers/v4.31.0/en/main_classes/pipelines#transformers.TextClassificationPipeline">TextClassificationPipeline</a>。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Transformers的pipelines提供了一种简单而强大的方式来使用预训练模型进行自然语言处理和图像识别任务。通过使用通用的<code>pipeline()</code>函数，我们可以轻松地加载默认模型或指定模型，并进行推理。</p><p>对于文本任务，例如文本分类、命名实体识别和文本摘要等，我们可以使用相应的pipeline来处理文本。例如，对于文本摘要任务，我们可以使用<code>pipeline(&quot;summarization&quot;)</code>来生成文本摘要。</p><p>对于图像识别任务，我们可以使用<code>pipeline(&quot;image-classification&quot;)</code>来进行图像识别。通过加载图像并使用pipeline进行识别，我们可以轻松地获取图像的标签和相应的分数。</p><p><code>pipeline()</code>函数还支持一些通用模型参数和特定任务参数。例如，我们可以使用<code>device</code>参数来指定模型推理所在的设备，以及使用<code>return_all_scores</code>参数来决定是否返回所有预测分数。</p><p>Transformers的pipelines提供了一种简单而高效的方式来使用预训练模型进行自然语言处理和图像识别任务。无论是处理文本还是图像，使用pipelines可以让我们更轻松地进行推理，并获得高质量的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hugging Face </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hugging Face入门 (AutoClass)</title>
      <link href="/2023/08/06/Hugging%20Face%E5%85%A5%E9%97%A82/"/>
      <url>/2023/08/06/Hugging%20Face%E5%85%A5%E9%97%A82/</url>
      
        <content type="html"><![CDATA[<h1 id="Hugging-Face入门-AutoClass"><a href="#Hugging-Face入门-AutoClass" class="headerlink" title="Hugging Face入门 (AutoClass)"></a>Hugging Face入门 (AutoClass)</h1><p>Transformers 提供了 AutoTokenizer 和 AutoModel 这两个类来方便加载预训练模型及其对应的分词器。</p><h2 id="AutoTokenizer"><a href="#AutoTokenizer" class="headerlink" title="AutoTokenizer"></a>AutoTokenizer</h2><p>AutoTokenizer 是一个用于文本预处理的分词器，它负责将输入文本转换为数字数组，以便输入模型进行处理。分词器会按照一定的规则进行分词，包括如何切分单词以及以何种级别进行切分。您可以根据模型的名称来实例化一个特定的分词器。为了确保分词的一致性，我们建议使用与模型预训练时相同的分词器。</p><p>更多关于分词的详细知识，请参考 <a href="https://huggingface.co/docs/transformers/quicktour#autoclass">autoclass</a>。</p><h2 id="AutoModel"><a href="#AutoModel" class="headerlink" title="AutoModel"></a>AutoModel</h2><p>与 AutoTokenizer 类似，AutoModel 提供了一种简单而统一的方式来加载预训练模型。您可以像加载 AutoTokenizer 一样加载 AutoModel。唯一的区别在于选择适用于您任务的正确 AutoModel。您可以在官方文档中找到所需模型的名称。</p><p>更多关于 AutoModel 的信息，请参考 <a href="https://huggingface.co/docs/transformers/quicktour#automodel">automodel</a>。</p><h2 id="ChatGLM-6B-模型"><a href="#ChatGLM-6B-模型" class="headerlink" title="ChatGLM-6B 模型"></a>ChatGLM-6B 模型</h2><p>ChatGLM-6B 是一个开源的、支持中英双语问答的对话语言模型。您可以在 <a href="https://huggingface.co/THUDM/chatglm-6b">chatglm-6b</a> 找到关于 ChatGLM-6B 的更多信息。</p><h2 id="使用AutoClass加载ChatGLM-6B，实现中文问答"><a href="#使用AutoClass加载ChatGLM-6B，实现中文问答" class="headerlink" title="使用AutoClass加载ChatGLM-6B，实现中文问答"></a>使用AutoClass加载ChatGLM-6B，实现中文问答</h2><p>为了实现中文问答，首先需要安装 transformers 和 sentencepiece 库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 transformers 和 sentencepiece 库</span></span><br><span class="line">!pip install git+https://github.com/huggingface/transformers sentencepiece --quiet</span><br></pre></td></tr></table></figure><h3 id="AutoTokenizer生成tokenizer，以便输入模型进行文本处理"><a href="#AutoTokenizer生成tokenizer，以便输入模型进行文本处理" class="headerlink" title="AutoTokenizer生成tokenizer，以便输入模型进行文本处理"></a>AutoTokenizer生成tokenizer，以便输入模型进行文本处理</h3><p>使用 <code>AutoTokenizer.from_pretrained</code> 方法加载 ChatGLM-6B 模型。<br>用tokenizer将中文输入，转换为数字数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line">model_id = <span class="string">&quot;THUDM/chatglm-6b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 AutoTokenizer 加载模型</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_id, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 tokenizer 将中文输入转换为数字数组</span></span><br><span class="line">encoding = tokenizer(<span class="string">&quot;你今天吃了吗？&quot;</span>)</span><br><span class="line">encoding</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;input_ids&#x27;</span>: [<span class="number">5</span>, <span class="number">98172</span>, <span class="number">66826</span>, <span class="number">63964</span>, <span class="number">31</span>, <span class="number">130001</span>, <span class="number">130004</span>]&#125;</span><br></pre></td></tr></table></figure><h3 id="AutoModel加载模型，使用tokenizer进行本文分析并输出"><a href="#AutoModel加载模型，使用tokenizer进行本文分析并输出" class="headerlink" title="AutoModel加载模型，使用tokenizer进行本文分析并输出"></a>AutoModel加载模型，使用tokenizer进行本文分析并输出</h3><p>使模型在推理阶段获得更佳的性能，达到以较快的速度，得到更准确的输出: </p><ul><li>.cuda(): 可以将模型加载到 GPU 上，利用GPU进行加速。  </li><li>.half(): 将模型的数据类型从float32改为float16，来减小模型大小并加速计算。  </li><li>model.eval(): 将模型设置为eval模式，下会关闭dropout等随机操作,可以改善推理效果。  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModel</span><br><span class="line"></span><br><span class="line">model_id = <span class="string">&quot;THUDM/chatglm-6b&quot;</span></span><br><span class="line"><span class="comment"># 使用 AutoModel 加载模型</span></span><br><span class="line">model = AutoModel.from_pretrained(model_id, trust_remote_code=<span class="literal">True</span>).half().cuda()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(model.__class__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型设置为 eval 模式</span></span><br><span class="line">model = model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;什么是量子化？&quot;</span></span><br><span class="line"><span class="comment"># tokenizer来自于AutoTokenizer</span></span><br><span class="line">response, history = model.chat(tokenizer, prompt, history=[])</span><br><span class="line">response</span><br><span class="line"></span><br><span class="line">量子化是一种数学方法，用于描述量子系统的性质和行为。在量子力学中，量子系统是由一系列微观粒子(称为“粒子”)组成的，这些粒子之间存在着特定的相互作用，使得量子系统具有一些与传统物理量不同的性质，例如量子叠加态和量子纠缠等。\n\n量子化方法可以用于描述量子系统的性质和行为，例如计算量子系统的态和相互作用，研究量子现象的机制，以及开发量子计算机等。在量子化学、量子信息学和量子物理学等领域，量子化方法都扮演着非常重要的角色。</span><br></pre></td></tr></table></figure><p><strong>通过以上步骤，您可以使用 ChatGLM-6B 模型实现中文问答，并获得更快速和准确的输出。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Transformers AutoClass 提供了一种为自然语言处理任务加载分词器和模型的便捷方法。  </p><p>使用AutoTokenizer和AutoModel，可以轻松地预处理文本并加载相应的模型以执行各种任务。 </p><p>ChatGLM-6B，作为一个强大的语言模型的例子，支持双语问答，可以使用AutoClass加载。 </p><p>按照给定的步骤，您可以有效地使用ChatGLM-6B实现中文问答。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hugging Face </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降算法的梯度方向</title>
      <link href="/2023/08/03/%E6%A2%AF%E5%BA%A6%E6%96%B9%E5%90%91/"/>
      <url>/2023/08/03/%E6%A2%AF%E5%BA%A6%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="梯度下降算法的梯度方向"><a href="#梯度下降算法的梯度方向" class="headerlink" title="梯度下降算法的梯度方向"></a>梯度下降算法的梯度方向</h1><p>在多元函数中，如果我们沿着函数梯度的方向运动，函数的值会以最快的速度增加；相反，如果我们沿着函数梯度的反方向运动，函数的值会以最快的速度减小。</p><h2 id="梯度的基本概念"><a href="#梯度的基本概念" class="headerlink" title="梯度的基本概念"></a>梯度的基本概念</h2><p>梯度(gradient)是微积分和向量分析中的重要概念，它可以理解为多元函数全部偏导数所构成的向量。<br>例如，二元函数f(x,y)的梯度是由函数f对x和y求偏导组成的二维向量。</p><p><img src="/img/blog/gradient/梯度基本概念.png" alt="梯度基本概念"></p><h2 id="二元函数与函数上某点的梯度"><a href="#二元函数与函数上某点的梯度" class="headerlink" title="二元函数与函数上某点的梯度"></a>二元函数与函数上某点的梯度</h2><p>考虑二元函数f(x,y)=x^2+y^2，在点(1,1)处的梯度向量如下图所示。<br>将函数上的点P(1,1,2)标记为红色，将该点向灰色的x-o-y平面投影，标记为蓝色。<br>从蓝色点出发，画出向量(2,2)，用黑色箭头表示，这就是点P的梯度向量。</p><p><img src="/img/blog/gradient/二元函数梯度.png" alt="二元函数梯度"></p><p>由此可见，从输入点(1,1)沿着(2,2)方向运动，函数会增加最快。</p><h2 id="梯度向量的具体算法"><a href="#梯度向量的具体算法" class="headerlink" title="梯度向量的具体算法"></a>梯度向量的具体算法</h2><p>从点P出发，向不同方向运动相同长度，可以发现只有沿着梯度方向运动，函数值变化最快。</p><p>基于俯视角度观察函数，在x-o-y平面上，我们可以沿着三个方向向量：(-1,0), (1,0), (2,2)，移动一个单位。</p><ul><li>从P点向(-1,0)方向到达A点，A点的函数值为f(0,1) = 0^2 + 1^2 = 1</li></ul><p><img src="/img/blog/gradient/梯度方向验证A.png" alt="梯度方向验证A"></p><ul><li><p>从P点向(1,0)方向到达B点，B点的函数值为f(2,1) = 2^2 + 1^2 = 5</p></li><li><p>从P点向(2,2)方向到达C点，C点的函数值为f(1.7,1.7) = 1.7^2 + 1.7^2 = 5.828</p></li></ul><p><img src="/img/blog/gradient/梯度方向验证BC.png" alt="梯度方向验证BC"></p><p>在机器学习中，我们通常希望找到目标函数的最小值。<br>为了达到这个目标，我们可以从某一个点出发，沿着梯度的反方向运动，这样函数的值会以最快的速度减小。<br>通过这种方式，我们可以更快地将函数收敛到最小值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>梯度下降算法的关键在于选择合适的梯度方向进行更新。  </p><p>我们通过计算函数的梯度向量，可以确定沿着何种方向函数值变化最快。  </p><p>在机器学习中，这个概念非常重要，因为我们经常需要通过梯度下降来优化模型的参数。  </p><p>通过沿着逐渐减小的梯度方向迭代更新参数，我们能够有效地寻找目标函数的最小值。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UserCF算法</title>
      <link href="/2023/07/30/UserCF%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/30/UserCF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="UserCF算法"><a href="#UserCF算法" class="headerlink" title="UserCF算法"></a>UserCF算法</h1><p>UserCF (User-based Collaborative Filtering)算法使用朴素的“人以群分”的思想。<br>基本思路是先找到相似用户，再找到他们喜欢的物品。<br>例如，如果用户A和用户B是相似的，现在给用户A推荐物品，就可以把用户B关注的但用户A没关注的物品推荐给用户A。<br><img src="/img/blog/UserCF/推荐原理.png" alt="推荐原理"></p><h2 id="UserCF算法步骤"><a href="#UserCF算法步骤" class="headerlink" title="UserCF算法步骤"></a>UserCF算法步骤</h2><p>步骤1：找到与待推荐用户兴趣相似的用户集合<br>步骤2：从这些相似用户喜欢的物品中选出目标用户没有关注的物品，并将它们推荐给目标用户</p><h2 id="用户相似度"><a href="#用户相似度" class="headerlink" title="用户相似度"></a>用户相似度</h2><p>基于用户行为相似度，计算兴趣相似度。具体来说，用户行为是指喜欢某些物品。<br>将不同用户喜欢的物品列表看做是不同的集合，通过集合求相似的方法，得出用户行为相似度。<br><img src="/img/blog/UserCF/用户相似度.png" alt="用户相似度"></p><h3 id="Jaccard相似系数"><a href="#Jaccard相似系数" class="headerlink" title="Jaccard相似系数"></a>Jaccard相似系数</h3><p>Jaccard相似系数可以比较有限集合(A与B)之间的相似性和差异性。<br>Jaccard系数等于A与B交集的大小除以A与B并集的大小，取值范围在0到1之间。<br>越接近1表示越相似，越接近0表示越不相似。<br>1代表两个集合完全相似，0代表两个集合完全没有交集。<br><img src="/img/blog/UserCF/Jaccard相似算法.png" alt="Jaccard相似算法"></p><h3 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h3><p>余弦相似度计算公式为：Cos(A,B) = (A和B交集大小) / 根号下(A集合大小 * B集合大小)，取值范围在0到1之间。<br>越接近1表示越相似，越接近0表示越不相似。<br>1代表两个集合完全相似，0代表两个集合完全没有交集。<br><img src="/img/blog/UserCF/余弦相似度.png" alt="余弦相似度"></p><h2 id="UserCF推荐算法"><a href="#UserCF推荐算法" class="headerlink" title="UserCF推荐算法"></a>UserCF推荐算法</h2><p>得到用户之间兴趣相似度后，接下来要对某个用户进行推荐。<br>UserCF算法会为用户推荐与他兴趣最相似的K个用户的感兴趣物品，并且会对推荐物品进行排序。<br><img src="/img/blog/UserCF/UserCF推荐算法.png" alt="UserCF推荐算法"></p><h2 id="UserCF推荐算法案例"><a href="#UserCF推荐算法案例" class="headerlink" title="UserCF推荐算法案例"></a>UserCF推荐算法案例</h2><h3 id="用户物品评分表"><a href="#用户物品评分表" class="headerlink" title="用户物品评分表"></a>用户物品评分表</h3><p>设置有ABCD 4个用户，abcde 5个物品，每个用户对每个物品都有一个评分，该评分代表用户对物品喜爱程度。<br><img src="/img/blog/UserCF/用户物品评分表.png" alt="用户物品评分表"></p><h3 id="用户C与每个用户相似度"><a href="#用户C与每个用户相似度" class="headerlink" title="用户C与每个用户相似度"></a>用户C与每个用户相似度</h3><p>结合用户评分表，可以用余弦相似度，求出用户C与每个用户相似度。  </p><p>C与A相似度 = N(C)与N(A)的交集数量 / 根号下(N(C)元素数量 * N(A)元素数量)<br>其中N(C)中包含b和e，N(A)中包含a,b,d，因此在分子中N(C)与N(A)的交集是b，对应数量是1；分母中两个集合元素数量相乘，等于根号6。<br><img src="/img/blog/UserCF/用户相似度案例.png" alt="用户相似度案例"></p><h3 id="用户C的物品推荐"><a href="#用户C的物品推荐" class="headerlink" title="用户C的物品推荐"></a>用户C的物品推荐</h3><p>根据用户C与每个用户相似度，为用户C推荐物品</p><p>根据用户A、B、C 3个用户的情况，为用户C推荐，K=3。<br>C没有关注过的物品为a、c、d，公式中u=C，i={a,c,d}<br>为a、c、d 3个物品进行排序，就是计算出P(C,a)、P(C,c)、P(C,d)，然后再排序。<br><img src="/img/blog/UserCF/用户推荐案例.png" alt="用户推荐案例"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UserCF算法是一种基于用户行为相似度的协同过滤算法。  </p><p>通过计算用户之间的兴趣相似度，找到与目标用户兴趣相似的用户集合，并推荐这些用户喜欢的，但目标用户没有关注的物品。 </p><p>Jaccard相似系数和余弦相似度是常用的用户相似度计算方法。  </p><p>UserCF算法可以为用户提供个性化的推荐结果。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hugging Face入门 (Transformers/Tokenizer/Pipeline)</title>
      <link href="/2023/07/29/Hugging%20Face%E5%85%A5%E9%97%A81/"/>
      <url>/2023/07/29/Hugging%20Face%E5%85%A5%E9%97%A81/</url>
      
        <content type="html"><![CDATA[<h1 id="Hugging-Face入门-Transformers-Tokenizer-Pipeline"><a href="#Hugging-Face入门-Transformers-Tokenizer-Pipeline" class="headerlink" title="Hugging Face入门 (Transformers/Tokenizer/Pipeline)"></a>Hugging Face入门 (Transformers/Tokenizer/Pipeline)</h1><p>Hugging Face是一个开源的自然语言处理（NLP）库，提供了许多工具和模型，帮助用户进行文本处理、模型调用和预训练模型的微调等任务。下面介绍了一些与Hugging Face相关的重要概念和步骤。</p><h2 id="Transformers"><a href="#Transformers" class="headerlink" title="Transformers"></a>Transformers</h2><p>Transformers是Huggingface开源的基于transformer模型结构提供的预训练语言库，支持PyTorch和TensorFlow2.0。它提供了快速的模型调用功能，并支持模型的进一步训练和微调。</p><h2 id="Tokenizer"><a href="#Tokenizer" class="headerlink" title="Tokenizer"></a>Tokenizer</h2><p>Tokenizer是Transformers库中的一个重要模块，用于将文本数据切分成单独的标记（tokens）并进行编码，以便交给模型进行处理。在自然语言处理（NLP）中，将文本转换成标记是一个重要的预处理步骤。不同的模型可能使用不同类型的Tokenizer来处理文本数据，例如BERTTokenizer、GPT2Tokenizer等。</p><h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>HuggingFace提供了一个接口，称为Pipeline，使得在Transformers库中使用预训练模型更加简单。通过Pipeline，您可以轻松地对输入文本进行处理并获取模型的输出结果，而无需手动进行繁琐的预处理和后处理步骤。例如，您可以使用TextClassificationPipeline对输入文本进行分类，或使用TextGenerationPipeline生成一段文本。</p><h2 id="基于bart-large-cnn模型进行文本摘要生成"><a href="#基于bart-large-cnn模型进行文本摘要生成" class="headerlink" title="基于bart-large-cnn模型进行文本摘要生成"></a>基于<code>bart-large-cnn</code>模型进行文本摘要生成</h2><p>以下是进行文本摘要生成的步骤：</p><ul><li><p>安装Transformers包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install transformers datasets --quiet</span><br></pre></td></tr></table></figure></li><li><p>定义所需的模型ID，<a href="https://huggingface.co/facebook/bart-large-cnn。">facebook/bart-large-cnn</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model_id = <span class="string">&quot;facebook/bart-large-cnn&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>准备要进行摘要生成的文本，将其赋值给变量<code>content</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The explosion of consumer-facing tools that offer generative AI has created plenty of debate: These tools promise to transform the ways in which we live and work while also raising fundamental questions about how we can adapt to a world in which they&#x27;re extensively used for just about anything.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">As with any new technology riding a wave of initial popularity and interest, it pays to be careful in the way you use these AI generators and bots—in particular, in how much privacy and security you&#x27;re giving up in return for being able to use them.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It&#x27;s worth putting some guardrails in place right at the start of your journey with these tools, or indeed deciding not to deal with them at all, based on how your data is collected and processed. Here&#x27;s what you need to look out for and the ways in which you can get some control back.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用Transformers库中的pipeline函数调用模型，其中pipline第一个参数task表示模型执行任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"></span><br><span class="line">pipeline = pipeline(<span class="string">&quot;summarization&quot;</span>, model=model_id)</span><br></pre></td></tr></table></figure><p><a href="https://huggingface.co/docs/transformers/quicktour">https://huggingface.co/docs/transformers/quicktour</a><br><img src="/img/blog/huggingface1/pipeline_task.png" alt="pipeline_task"></p></li><li><p>输出生成的摘要内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline(content)</span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&#x27;summary_text&#x27;</span>: <span class="string">&quot;The explosion of consumer-facing tools that offer generative AI has created plenty of debate. It&#x27;s worth putting some guardrails in place right at the start of your journey with these tools. Here&#x27;s what you need to look out for and the ways in which you can get some control back.&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></li></ul><p>以上是使用BART-large-cnn模型进行文本摘要生成的简要示例。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过Hugging Face的Transformers库，我们可以轻松地使用预训练的transformer模型进行文本处理和任务执行。  </p><p>Tokenizer模块帮助我们将文本数据切分成标记。  </p><p>而Pipeline接口则简化了模型调用和结果获取的过程。  </p><p>通过以上示例，您可以快速开始使用Hugging Face进行文本摘要生成的任务。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hugging Face </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConstitutionalChain</title>
      <link href="/2023/07/26/ConstitutionalChain/"/>
      <url>/2023/07/26/ConstitutionalChain/</url>
      
        <content type="html"><![CDATA[<h1 id="ConstitutionalChain"><a href="#ConstitutionalChain" class="headerlink" title="ConstitutionalChain"></a>ConstitutionalChain</h1><p>ConstitutionalChain是一种确保LLM（Large Language Model）模型输出符合预定义的宪法原则的机制。<br>通过融入特定的规则和指南，ConstitutionalChain对生成的内容进行过滤和修改，以使其与这些原则保持一致，从而提供更加受控、符合伦理和上下文适当的响应。这种机制有助于维护输出的完整性，同时最大限度地减少生成可能违反指南、具有冒犯性或偏离所期望上下文的内容的风险。</p><h2 id="修改prompt以引导LLM模型回答违规问题"><a href="#修改prompt以引导LLM模型回答违规问题" class="headerlink" title="修改prompt以引导LLM模型回答违规问题"></a>修改prompt以引导LLM模型回答违规问题</h2><p>尽管LLM模型一直在不断进行优化和更新，但通过修改prompt内容仍然可以诱导模型回答违法或违规的内容。<br>这表明在确保模型输出合规性方面，依然需要引入额外的机制。</p><p><img src="/img/blog/ConstitutionalChain/prompt_hacking.png" alt="prompt_hacking"></p><h2 id="使用ConstitutionalChain规避LLM模型输出违法内容"><a href="#使用ConstitutionalChain规避LLM模型输出违法内容" class="headerlink" title="使用ConstitutionalChain规避LLM模型输出违法内容"></a>使用ConstitutionalChain规避LLM模型输出违法内容</h2><p>为了规避LLM模型输出非法或违规的内容，使用ConstitutionalChain是一种有效的方法。</p><p><img src="/img/blog/ConstitutionalChain/constitutional_chain_input.png" alt="constitutional_chain_input"></p><p>当Constitutional AI检测到模型回答中存在违规或不道德的内容时，它会及时更新模型的输出，确保输出内容符合法律法规和伦理准则。  </p><p><img src="/img/blog/ConstitutionalChain/constitutional_chain_output.png" alt="constitutional_chain_output"></p><h2 id="通过ConstitutionalChain优化和丰富模型回答"><a href="#通过ConstitutionalChain优化和丰富模型回答" class="headerlink" title="通过ConstitutionalChain优化和丰富模型回答"></a>通过ConstitutionalChain优化和丰富模型回答</h2><p>ConstitutionalChain不仅可以检测和处理非法内容，还可以改进和丰富模型的回答。<br>当Constitutional AI检测到模型回答内容没有问题，但缺乏足够的解释或细节时，它会对模型的回答进行修改，提供更全面和详细的答案。<br>这样可以提升模型回答的质量和完整性。</p><p><img src="/img/blog/ConstitutionalChain/constitutional_chain_improvement.png" alt="constitutional_chain_improvement"></p><h2 id="支持自定义规则的ConstitutionalChain"><a href="#支持自定义规则的ConstitutionalChain" class="headerlink" title="支持自定义规则的ConstitutionalChain"></a>支持自定义规则的ConstitutionalChain</h2><p>ConstitutionalChain支持自定义规则，可以根据特定需求调整模型的行为。<br>每个规则包括：name规则名称，critique_request对违规内容的定义，revision_request模型在遇到自定义违规内容时应如何修改输出。<br>这为用户提供了更大的灵活性，能够根据自身需求来指导模型的行为。</p><p><img src="/img/blog/ConstitutionalChain/constitutional_chain_custom.png" alt="constitutional_chain_custom"></p><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>ConstitutionalChain为我们解决LLM模型输出违规问题提供了一个有效的机制。  </p><p>随着技术的不断进步和研究的深入，我们可以期待ConstitutionalChain的应用范围进一步扩大。  </p><p>未来可能会有更多的定制规则和改进算法被引入，以进一步提升模型的合规性和质量。  </p><p>借助ConstitutionalChain，我们能够更好地应对模型输出中潜在的违法内容，并为用户提供更加安全和符合要求的回答。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>Constitutional AI论文：<a href="https://examine.dev/docs/Unified_objectives.pdf">链接</a></li><li>ConstitutionalChain官方文档：<a href="https://python.langchain.com/docs/guides/safety/constitutional_chain">链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> AI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PySpark AI 简介</title>
      <link href="/2023/07/24/PySpark%20AI%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/24/PySpark%20AI%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="PySpark-AI-基于自然语言的大规模数据分析"><a href="#PySpark-AI-基于自然语言的大规模数据分析" class="headerlink" title="PySpark AI: 基于自然语言的大规模数据分析"></a>PySpark AI: 基于自然语言的大规模数据分析</h1><p>PySpark AI是一个开源项目，旨在通过使用自然语言作为程序语言进行大规模数据分析。<br><img src="/img/blog/spark_ai/spark_ai.png" alt="spark_ai"></p><h2 id="自然语言作为程序语言的特性"><a href="#自然语言作为程序语言的特性" class="headerlink" title="自然语言作为程序语言的特性"></a>自然语言作为程序语言的特性</h2><p>自然语言作为程序语言具有以下特性，可以简化Spark数据开发过程：</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>通过用户提供的描述，PySpark AI可以执行web搜索并利用LLM确定最合适的结果。然后，它可以顺利地将选择的web数据合并到Spark中，所有这些都是在一个步骤中完成的。</p><h3 id="DataFrame操作"><a href="#DataFrame操作" class="headerlink" title="DataFrame操作"></a>DataFrame操作</h3><p>PySpark AI允许用户使用自然语言描述来进行DataFrames的转换、绘图和解释。这些特性显著增强了代码的可读性和效率，使对DataFrames的操作变得简单直观。</p><h3 id="用户自定义函数（UDFs）"><a href="#用户自定义函数（UDFs）" class="headerlink" title="用户自定义函数（UDFs）"></a>用户自定义函数（UDFs）</h3><p>通过一个简单的装饰器，用户只需要提供一个文档字符串，PySpark AI将处理代码的其余部分。这个特性简化了UDF的创建过程，让用户可以更专注于函数定义。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>PySpark AI集成了缓存功能，以提高执行速度、生成可重复的结果并节省成本。</p><h2 id="PySpark-AI案例：分析上市公司的股东持股情况"><a href="#PySpark-AI案例：分析上市公司的股东持股情况" class="headerlink" title="PySpark AI案例：分析上市公司的股东持股情况"></a>PySpark AI案例：分析上市公司的股东持股情况</h2><p>下面是一个简单的案例，展示了如何使用PySpark AI分析一家上市公司的前十位股东的持股情况。</p><ul><li>安装和设置<br>首先，需要安装pyspark-ai并设置openai api key。<br><img src="/img/blog/spark_ai/spark_ai案例1.png" alt="spark_ai案例1">  </li></ul><ul><li>实例化ChatOpenAI和SparkAI<br>然后，需要实例化ChatOpenAI和SparkAI对象。<br><img src="/img/blog/spark_ai/spark_ai案例2.png" alt="spark_ai案例2"></li></ul><ul><li>创建DataFrames<br>接下来，输入雅虎财经官方网站的URL，创建DataFrames。<br>雅虎财经: <a href="https://finance.yahoo.com/quote/AAPL/holders?p=AAPL">https://finance.yahoo.com/quote/AAPL/holders?p=AAPL</a><br><img src="/img/blog/spark_ai/spark_ai案例3.png" alt="spark_ai案例3"></li></ul><ul><li>生成图表<br>在不输入任何描述信息的情况下，可以根据DataFrames生成图表。<br><img src="/img/blog/spark_ai/spark_ai案例4.png" alt="spark_ai案例4"></li></ul><ul><li>使用自然语言描述生成饼图<br>通过使用自然语言告诉DataFrames，可以生成饼图的图表。<br><img src="/img/blog/spark_ai/spark_ai案例5.png" alt="spark_ai案例5"></li></ul><ul><li>转换DataFrames并获取持股比例最高的股东信息<br>使用自然语言将DataFrames转换为持股比例最高的股东的名字和百分比。<br><img src="/img/blog/spark_ai/spark_ai案例6.png" alt="spark_ai案例6"></li></ul><ul><li><p>explain函数总结<br>调用explain函数让AI进行操作总结。<br><img src="/img/blog/spark_ai/spark_ai案例7.png" alt="spark_ai案例7"></p></li><li><p>verify函数验证<br>调用verify函数确保最高持股者的比例不超过10%。<br><img src="/img/blog/spark_ai/spark_ai案例8.png" alt="spark_ai案例8"></p></li></ul><h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>尽管PySpark AI目前还处于早期开发阶段，功能上还不太成熟，但考虑到它可以基于自然语言处理，简化大规模数据分析的过程，这个项目具有巨大的潜力。 </p><p>随着AI技术的进步和开发者的不断贡献，我们可以期待PySpark AI在未来能够提供更多功能和更高的性能，进一步推动数据分析的发展。</p>]]></content>
      
      
      <categories>
          
          <category> AI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT Custom Instructions</title>
      <link href="/2023/07/22/ChatGPT%20Custom%20Instructions/"/>
      <url>/2023/07/22/ChatGPT%20Custom%20Instructions/</url>
      
        <content type="html"><![CDATA[<h2 id="ChatGPT-Custom-Instructions"><a href="#ChatGPT-Custom-Instructions" class="headerlink" title="ChatGPT Custom Instructions"></a>ChatGPT Custom Instructions</h2><p>ChatGPT Custom Instructions使用户可以根据自己的需求定制ChatGPT，并允许添加偏好和要求，以便在生成回复时加以考虑。</p><p>OpenAI通过custom instructions深化了ChatGPT的可操控性，使其能够更好地适应每个人的多样化背景和独特需求，这在理解关键方面起到了关键作用。</p><p>ChatGPT将在每次对话中考虑用户的custom instructions，这样用户无需在每次对话中重复提供自己的偏好或信息。</p><h3 id="Custom-Instructions效果对比"><a href="#Custom-Instructions效果对比" class="headerlink" title="Custom Instructions效果对比"></a>Custom Instructions效果对比</h3><p>下图展示了一个custom instructions的示例：</p><p><img src="/img/blog/custom_instructions/custom_instructions例子.png" alt="custom_instructions例子"></p><p>启用custom instructions后，对ChatGPT提问：”Write me code for getting the nth number in Fibonacci sequence”</p><p>ChatGPT的回复中只提供了GO代码。<br><img src="/img/blog/custom_instructions/custom_instructions_go.png" alt="custom_instructions_go"></p><p>关闭custom instructions后，对ChatGPT提问相同的问题：”Write me code for getting the nth number in Fibonacci sequence”</p><p>这次ChatGPT的回复提供了Python代码，并附带详细的代码说明。然而，如果用户是GO程序员，则需要进一步调整回复以满足其需求。<br><img src="/img/blog/custom_instructions/custom_instructions_python.png" alt="custom_instructions_python"></p><h3 id="Custom-Instructions设置"><a href="#Custom-Instructions设置" class="headerlink" title="Custom Instructions设置"></a>Custom Instructions设置</h3><p>在第一个文本框中，我们可以告诉ChatGPT自己的偏好以及想要讨论的主题。</p><p><img src="/img/blog/custom_instructions/custom_instructions设置1.png" alt="custom_instructions设置1"></p><p>在第二个文本框中，我们可以告诉ChatGPT我们希望它在回复时遵循的风格、字数和偏好。</p><p><img src="/img/blog/custom_instructions/custom_instructions设置2.png" alt="custom_instructions设置2"></p><h3 id="Custom-Instructions的例子"><a href="#Custom-Instructions的例子" class="headerlink" title="Custom Instructions的例子"></a>Custom Instructions的例子</h3><p>以下是一些Custom Instructions的示例：</p><ul><li>查询：请在回答中提供最新的英文资料，并在紧随其后的括号中列出具体的来源链接。</li><li>文章润色：请纠正文稿中的拼写和错误，并注意标点符号的使用。在润色完成后，请附加说明修改了哪些内容以及原因。</li><li>审视：当要求ChatGPT审视内容时，请将自己视为一个经验丰富的领域专家，仔细审视前面的问题，并思考是否存在错误或需要补充的地方。如果有的话，请根据查询资料的结果替换或添加内容。</li></ul><p>上述Custom Instructions的例子可以在单个或多个对话场景中相互调用，并且它们并不是独立起作用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用Custom Instructions，您可以让ChatGPT记住您的特点和定制化要求。  </p><p>此外，指令可以进行嵌套调用，从而降低ChatGPT的使用复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> AI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/3协议：提升网络性能与解决传输层问题</title>
      <link href="/2023/07/20/HTTP3/"/>
      <url>/2023/07/20/HTTP3/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-3协议：提升网络性能与解决传输层问题"><a href="#HTTP-3协议：提升网络性能与解决传输层问题" class="headerlink" title="HTTP/3协议：提升网络性能与解决传输层问题"></a>HTTP/3协议：提升网络性能与解决传输层问题</h1><p>HTTP/3由互联网工程任务组(IETF)，在2022年6月作为RFC 9114提议的标准发布</p><h2 id="为什么需要新协议"><a href="#为什么需要新协议" class="headerlink" title="为什么需要新协议"></a>为什么需要新协议</h2><p>HTTP/2在数据传输阶段，虽然在应用层多个请求可以同时发送，但是传输层TCP协议要求数据包必须按顺序串行传输。<br>如果其中一个数据包丢失或者延迟，后续的数据包就需要等待重传，或者等待前面数据包传输完成后才能发送，也就是说队头阻塞问题并没有彻底解决。<br><img src="/img/blog/http3/http2队头阻塞问题.png" alt="http2队头阻塞问题"><br>由此可得，HTTP/2主要性能瓶颈在传输层TCP协议。  </p><h2 id="TCP协议解决方案"><a href="#TCP协议解决方案" class="headerlink" title="TCP协议解决方案"></a>TCP协议解决方案</h2><h3 id="TCP协议升级-×"><a href="#TCP协议升级-×" class="headerlink" title="TCP协议升级(×)"></a>TCP协议升级(×)</h3><p>为了解决上述问题，有2个升级TCP协议的方案</p><ul><li>Fast Open：缩短连接建立时间</li><li>BBR算法：避免拥塞和队头阻塞  </li></ul><p>但是TCP协议被广泛内置于操作系统内核、中间件固件以及硬件实现中，这些系统和设备都需要进行代码更新、测试和部署，才能支持新的TCP协议改进版本。<br>这个过程需要花费大量时间和精力，并且需要保证向后兼容性，以确保老版本的TCP协议和新版本TCP协议，可以共存于同一个网络中。<br><img src="/img/blog/http3/TCP协议升级.png" alt="TCP协议升级"></p><h3 id="TCP协议更换UDP协议-×"><a href="#TCP协议更换UDP协议-×" class="headerlink" title="TCP协议更换UDP协议(×)"></a>TCP协议更换UDP协议(×)</h3><p>另一个方案解决是换一种传输层协议，可替换的UDP协议是一种无连接，不可靠的协议，不能解决HTTP的问题。  </p><h3 id="QUIC协议的发布"><a href="#QUIC协议的发布" class="headerlink" title="QUIC协议的发布"></a>QUIC协议的发布</h3><p>Google发布一个基于UDP应用层的传输协议，叫做QUIC协议(Quick UDP Internet Connections)<br>它在用户空间实现类似TCP的流量控制、拥塞控制和重传机制等功能，从而提供可靠的数据传输，它的设计目的是替代TCP，开发一种更灵活、更高性能的传输协议。<br><img src="/img/blog/http3/QUIC协议发布.png" alt="QUIC协议发布"></p><h2 id="HTTP-3的QUIC协议"><a href="#HTTP-3的QUIC协议" class="headerlink" title="HTTP/3的QUIC协议"></a>HTTP/3的QUIC协议</h2><h3 id="基于UDP协议开发的原因"><a href="#基于UDP协议开发的原因" class="headerlink" title="基于UDP协议开发的原因"></a>基于UDP协议开发的原因</h3><ul><li>避免重新部署和更新网络设备和系统：UDP协议已经被广泛部署在现有的网络设备和系统中，可以在不影响现有网络设备和系统的情况下，逐步推广和普及</li><li>UDP协议速度快，低延迟：由于UDP协议非常简单和轻量，它具有很快的速度，可以实现很好的网络性能</li></ul><h3 id="HTTP-3使用QUIC协议"><a href="#HTTP-3使用QUIC协议" class="headerlink" title="HTTP/3使用QUIC协议"></a>HTTP/3使用QUIC协议</h3><p>HTTP/3使用QUIC协议替代传输层TCP协议，它的主要目的是使HTTP语法和现有HTTP/2功能，与QUIC传输协议兼容<br><img src="/img/blog/http3/HTTP3_QUIC协议.png" alt="HTTP3_QUIC协议"> </p><h3 id="HTTP-3协议特性"><a href="#HTTP-3协议特性" class="headerlink" title="HTTP/3协议特性"></a>HTTP/3协议特性</h3><ul><li>安全性高：<br>QUIC集成TLS v1.3安全协议大部分特性，并使其兼容自身的传递机制，在传输层实现高级安全性。<br>在HTTP/3中，加密不是可选的，而是一项内置功能。<br>QUIC保留了包含加密密钥的TLS v1.3内容层，但用自己的传输功能替换了记录层。<br><img src="/img/blog/http3/http3安全性.png" alt="http3安全性">  </li></ul><ul><li>建立连接快：<br>HTTP/2协议在建立连接阶段，TCP三次握手，耗费1个RTT，TLS1.2完全握手耗费2个RTT；使用TLS1.3后简化握手需要1个RTT，所以使用TCP+TLS建立连接需要2-3个RTT。<br>QUIC基于UDP，同时集成TLS1.3，只需要1个RTT就可以完成安全连接的建立。<br><img src="/img/blog/http3/http3建立连接快.png" alt="http3建立连接快">  </li></ul><ul><li>解决队头阻塞：<br>QUIC存在Connection和Stream两个级别的概念，Stream可以认为就是一条HTTP请求，Connection可以类比一条TCP连接。<br>QUIC多路复用和HTTP2类似，在一条QUIC Connection上可以同时发送多个Stream，但是QUIC一个连接上的多个Stream之间相互独立没有依赖。<br>假如其中一个Stream丢包，也只会影响该Stream的处理，不会影响其他Stream，这也就在很大程度上缓解，甚至消除队头阻塞的影响。<br><img src="/img/blog/http3/http3队头阻塞.png" alt="http3队头阻塞"></li></ul><ul><li>支持连接迁移：<br>一条TCP连接是由四元组标识(源IP，源端口，目的IP，目的端口)，在手机使用WIFI和4G移动网络切换时，IP肯定会发生变化，就需要重新建立TCP连接。<br>一条QUCI连接不再以IP及端口四元组标识，而是以一个64位的随机数作为ID来标识，这样就算IP或者端口发生变化时，只要ID不变，这条连接依然维持。<br><img src="/img/blog/http3/http3连接迁移.png" alt="http3连接迁移">  </li></ul><ul><li>避免协议僵化：<br>QUIC协议是一个基于用户空间的协议，它的实现独立于操作系统内核，可以在应用层进行部署和更新，这使得QUIC协议更容易引入新的功能和改进<br><img src="/img/blog/http3/http3避免协议僵化.png" alt="http3避免协议僵化"></li></ul><h2 id="HTTP-3弊端"><a href="#HTTP-3弊端" class="headerlink" title="HTTP/3弊端"></a>HTTP/3弊端</h2><ul><li>网管难度大：由于QUIC加密级别高，相比于在报文中带有未加密元数据的TCP，提供防火墙和网络跟踪服务变得更加困难，目前很多防火墙尚不支持QUIC。  </li></ul><ul><li>UDP会被网络阻止：UDP经常被用于不同类型的网络攻击(例如：DDoS攻击)，因为攻击者可以轻易伪造IP地址，发送大量UDP数据包，导致目标服务器过载，从而无法正常处理合法请求，因此一些网络会阻止UDP协议。</li></ul><ul><li>UDP丢包处理难度大：UDP连接出现丢包情况，要交给应用层做重传处理，增大应用层复杂程度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP和HTTPS协议</title>
      <link href="/2023/07/18/HTTP&amp;HTTPS/"/>
      <url>/2023/07/18/HTTP&amp;HTTPS/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP和HTTPS协议：了解它们之间的区别"><a href="#HTTP和HTTPS协议：了解它们之间的区别" class="headerlink" title="HTTP和HTTPS协议：了解它们之间的区别"></a>HTTP和HTTPS协议：了解它们之间的区别</h1><p>HTTP（超文本传输协议）和HTTPS（安全套接字层超文本传输协议）是在互联网中广泛使用的两种协议。虽然它们都用于在客户端和服务器之间传输数据，但在安全性和加密方面存在着显著的差异。</p><h2 id="什么是HTTP协议？"><a href="#什么是HTTP协议？" class="headerlink" title="什么是HTTP协议？"></a>什么是HTTP协议？</h2><p>HTTP协议是一种明文传输协议，它以纯文本形式传输数据。当您在浏览器中键入网址并回车时，浏览器会向服务器发送一个HTTP请求，请求获取网页的内容。服务器接收到该请求后会返回相应的HTML文件，浏览器会将其解析并呈现给您。</p><p>然而，由于HTTP协议的传输过程是明文的，意味着数据在传输过程中是以可读的形式发送的。这种设计存在安全风险，攻击者可以窃听和窃取这些传输的数据，包括您的个人信息、登录凭证等。</p><h2 id="什么是HTTPS协议？"><a href="#什么是HTTPS协议？" class="headerlink" title="什么是HTTPS协议？"></a>什么是HTTPS协议？</h2><p>为了解决HTTP协议的安全问题，HTTPS协议应运而生。HTTPS是HTTP的安全版本，通过在 HTTP 上面添加安全层（TLS/SSL）来保护数据的传输过程。</p><p>在HTTPS协议中，数据在传输之前会被加密，使得攻击者无法轻易获取其中的内容。加密过程使用了公开密钥加密（Public Key Encryption）和对称密钥加密（Symmetric Key Encryption）等加密算法，以确保数据在传输过程中的保密性和完整性。</p><p>另外，HTTPS协议还使用了数字证书来对服务器进行身份验证。服务器会通过数字证书向浏览器证明自己的身份，并提供公钥用于加密通信。浏览器会验证证书的有效性和合法性，确保与服务器建立的连接是安全的。</p><h2 id="HTTP协议和HTTPS协议的关系"><a href="#HTTP协议和HTTPS协议的关系" class="headerlink" title="HTTP协议和HTTPS协议的关系"></a>HTTP协议和HTTPS协议的关系</h2><p>HTTP协议和HTTPS协议是相关但不同的协议。HTTP是最常用的协议之一，用于在浏览器和服务器之间传输数据。然而，由于其不加密的特性，HTTP协议存在着安全风险。</p><p>HTTPS是基于HTTP协议的扩展和改进版本。它在HTTP协议的基础上添加了安全层，以确保传输的数据在传输过程中不被攻击者拦截和窃取。因此，可以说HTTPS是HTTP的加强版，旨在提供更高的安全性和保护用户隐私的功能。</p><p>现代的浏览器和网站通常要求使用HTTPS来加密通信，以确保用户的敏感信息和数据的安全性。因此，可以说HTTP和HTTPS协议是紧密相关的，且HTTPS在保护网络通信安全方面扮演着重要的角色。</p><h2 id="HTTP协议和HTTPS协议的协同工作"><a href="#HTTP协议和HTTPS协议的协同工作" class="headerlink" title="HTTP协议和HTTPS协议的协同工作"></a>HTTP协议和HTTPS协议的协同工作</h2><p>HTTP协议和HTTPS协议可以在同一个网站上共存，但它们在数据传输和安全性方面有所不同。</p><p>当用户访问使用HTTPS的网站时，浏览器会向服务器发送一个HTTPS请求。服务器会将自己的数字证书发送给浏览器，并向其证明自己的身份。浏览器会验证证书的有效性和合法性，以确保与服务器建立的连接是安全的。</p><p>一旦连接建立，浏览器和服务器之间的通信将使用安全的加密算法进行加密。这确保了从浏览器到服务器的数据传输过程中的保密性和完整性。</p><p>同时，在使用HTTPS协议的网站上，浏览器还会对其他以HTTP方式加载的资源进行安全性检查。如果这些资源没有通过安全通道进行传输，则浏览器会发出警告并阻止加载该资源。</p><p>因此，HTTP协议和HTTPS协议通过共同工作，确保了Web通信的安全性。通过使用HTTPS，我们可以保护网站之间的数据传输安全，确保用户的隐私和数据的完整性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTP协议和HTTPS协议是互联网通信中的两个重要协议。</p><p>它们在安全性和加密等方面存在明显的区别。</p><p>通过使用HTTPS，我们可以保护网站之间的数据传输安全，从而确保用户的隐私和数据的完整性。</p><p>HTTP协议和HTTPS协议之间存在紧密的关系，在网络通信中协同工作，以提供更安全和可信赖的网络体验。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/2对网络传输的优化</title>
      <link href="/2023/07/13/HTTP2/"/>
      <url>/2023/07/13/HTTP2/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-2对网络传输的优化"><a href="#HTTP-2对网络传输的优化" class="headerlink" title="HTTP/2对网络传输的优化"></a>HTTP/2对网络传输的优化</h1><h2 id="HTTP-1-1存在问题"><a href="#HTTP-1-1存在问题" class="headerlink" title="HTTP/1.1存在问题"></a>HTTP/1.1存在问题</h2><p>HTTP/1.1持久连接允许客户端在同一个TCP连接上，同时发送多个请求，而无需等待前一个请求的响应，以此来充分利用等待响应过程中的时间。<br>但是HTTP是文本协议，请求和响应之间没有序号标识关联，无法将乱序的响应和请求关联起来，发送完一个请求，必须等到响应后才能发送下一个请求。<br>因此HTTP/1.1持久连接存在以下缺陷：  </p><ul><li><p>解析效率低：文本协议为了便于解析，协议中会加入一些特殊字符作为分隔符号，消息内容变得冗长，而且解析过程复杂，需要进行字符比较</p></li><li><p>停等协议：客户端需要等到响应后，才能发送下一个请求，等待时间客户端资源和网络利用率低</p></li><li><p>队头阻塞：如果其中一个请求非常耗时，或者因为某些原因没有及时响应，后面其他请求就会被阻塞</p></li><li><p>头信息重复传输：HTTP是无状态的协议，每次请求和带上所有头信息，头信息都是没有压缩的，尤其是UserAgent Cookie这类不会频繁变动的内容，但占用空间却很大，这样会造成网络带宽和流量的浪费</p></li></ul><p>为了优化上述问题，有以下2个方案：</p><ol><li>减少请求数量：常见做法是合并资源文件，将css、base64图片等资源内联</li><li>增加连接个数：一般浏览器，会把一个域名的并发连接数增加到6-8个  </li></ol><p>这些优化策略，虽然可以在一定程度上提高传输性能，但并没有完全解决问题。<br>因此HTTP/2应运而生</p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>HTTP/2采用二进制格式传输数据，支持多路复用和头部压缩等特性，是对HTTP/1.1协议一次比较彻底的改进和升级。  </p><h3 id="HTTP-2二进制分帧层"><a href="#HTTP-2二进制分帧层" class="headerlink" title="HTTP/2二进制分帧层"></a>HTTP/2二进制分帧层</h3><p>HTTP/2为了实现乱序请求和响应的关联，使通信双方能并发请求和响应。<br>在应用层与传输层之间，增加了二进制分帧层，将HTTP由文本协议转换成二进制协议。<br><img src="/img/blog/http2/http二进制协议.png" alt="http二进制协议">  </p><h4 id="HTTP-2二进制分帧层的帧和流是2个核心概念"><a href="#HTTP-2二进制分帧层的帧和流是2个核心概念" class="headerlink" title="HTTP/2二进制分帧层的帧和流是2个核心概念"></a>HTTP/2二进制分帧层的帧和流是2个核心概念</h4><p><strong>帧是数据传输的最小单位</strong><br><img src="/img/blog/http2/http分帧层.png" alt="http分帧层"><br>帧头一共有9字节，其中包含：</p><ul><li>Length</li><li>Type</li><li>Flags </li><li>Stream ID </li><li>Payloa</li></ul><p>HTTP/2把请求和响应报文，分成头部帧和数据帧，由type字段标识<br><img src="/img/blog/http2/http头部帧和数据帧.png" alt="http头部帧和数据帧"></p><p><strong>流是一个逻辑上的概念</strong><br>一个资源请求就是一个流，一个流由多个帧组成，用同一个流ID标识，接收方可以通过流ID将帧关联起来，从而实现乱序请求和响应关联<br><img src="/img/blog/http2/http流.png" alt="http流">  </p><h3 id="HTTP-2连接多路复用"><a href="#HTTP-2连接多路复用" class="headerlink" title="HTTP/2连接多路复用"></a>HTTP/2连接多路复用</h3><p>在二进制分帧层的基础上，一条TCP连接通信双方可以并发的请求和响应，实现多路复用。<br>发送端会把每个文件切割成多个数据帧并且编号，不同文件标记不同的流ID，三个文件可以同时发送。<br>接收端收到数据会根据不同的流ID，重新组装还原数据。<br><img src="/img/blog/http2/http多路复用.png" alt="http多路复用"></p><p>多路复用解决了HTTP应用层队头阻塞的问题，多个资源可以同时发送。<br>如图蓝色为请求，红色为响应，响应可以不是顺序的，这减少HTTP/1.1请求后等待响应的延迟。<br><img src="/img/blog/http2/http队头阻塞.png" alt="http队头阻塞">  </p><h3 id="HTTP-2-HPACK压缩算法"><a href="#HTTP-2-HPACK压缩算法" class="headerlink" title="HTTP/2 HPACK压缩算法"></a>HTTP/2 HPACK压缩算法</h3><h4 id="HTTP-2-HPACK压缩算法模块"><a href="#HTTP-2-HPACK压缩算法模块" class="headerlink" title="HTTP/2 HPACK压缩算法模块"></a>HTTP/2 HPACK压缩算法模块</h4><p>HTTP/2使用HPACK算法压缩头信息，用于减少头信息的大小，减少发送包的数量，从而降低延迟。<br>一次HTTP请求未经过压缩Header大约是2400 bytes。<br>使用HTTP/2经过压缩后，首次请求大小会减少到1574 bytes，后续请求会进一步减少到112 bytes。<br><img src="/img/blog/http2/http压缩算法例子.png" alt="http队头阻塞"></p><p>HPACK算法分为3个模块：</p><ul><li>静态表</li><li>动态表</li><li>Huffman编码  </li></ul><p><img src="/img/blog/http2/http_HPACK算法.png" alt="http_HPACK算法">  </p><h4 id="HTTP-2-HPACK压缩算法的主要思路"><a href="#HTTP-2-HPACK压缩算法的主要思路" class="headerlink" title="HTTP/2 HPACK压缩算法的主要思路"></a>HTTP/2 HPACK压缩算法的主要思路</h4><p>算法的主要压缩思路，是通过静态字典表和动态字典表，共享已知的HTTP头部字段，使用索引号来代替HTTP头部字段名和值，从而减少传输数据大小。<br>同时使用Huffman编码压缩字符串，进一步减少传输数据的体积。  </p><h5 id="HTTP-2-HPACK压缩算法静态表"><a href="#HTTP-2-HPACK压缩算法静态表" class="headerlink" title="HTTP/2 HPACK压缩算法静态表"></a>HTTP/2 HPACK压缩算法静态表</h5><p>静态表是预定义，包含61个常见HTTP头部字段和值，这些字段和值都是写死在协议中。<br>发送方可以通过发送静态表中对应的索引号，来替代完整的HTTP头部字段和值，从而实现压缩。<br><img src="/img/blog/http2/http静态表.png" alt="http静态表">  </p><h5 id="HTTP-2-HPACK压缩算法动态表"><a href="#HTTP-2-HPACK压缩算法动态表" class="headerlink" title="HTTP/2 HPACK压缩算法动态表"></a>HTTP/2 HPACK压缩算法动态表</h5><p>动态表是动态生成的，其中存储了请求或响应中出现HTTP头部字段和值。<br>发送方可以将动态表中的部分内容发送给接收方，并通过发送动态表中对应索引号，来代替完整HTTP头部字段和值，从而进一步减少传输数据大小。  </p><h5 id="HTTP-2-HPACK压缩算法Huffman编码"><a href="#HTTP-2-HPACK压缩算法Huffman编码" class="headerlink" title="HTTP/2 HPACK压缩算法Huffman编码"></a>HTTP/2 HPACK压缩算法Huffman编码</h5><p>Huffman编码，是一种基于字符出现频率，无损压缩编码方法。<br>通过赋予高频字符较短的编码，来实现数据压缩，而不会丢失任何信息。<br>在HPACK中，使用Huffman编码对HTTP头部字段和值进行压缩，从而进一步减少传输数据的体积。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTP/2的新机制，优化HTTP/1.1网络性能缺陷、降低延迟、提高吞吐量，使得网页资源加载速度更快</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP1诞生到完善</title>
      <link href="/2023/07/11/HTTP1/"/>
      <url>/2023/07/11/HTTP1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP1诞生到完善"><a href="#HTTP1诞生到完善" class="headerlink" title="HTTP1诞生到完善"></a>HTTP1诞生到完善</h1><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><h3 id="HTTP-1-0多数据格式传输"><a href="#HTTP-1-0多数据格式传输" class="headerlink" title="HTTP/1.0多数据格式传输"></a>HTTP/1.0多数据格式传输</h3><p>HTTP/1.0在1996年发布。<br>通过在请求和响应报文增加头信息来描述传输数据的元信息，从而支持了任意格式的数据传输与处理。<br>客户端需要再HTTP请求头中指定可以处理的数据类型，同时服务端在响应请求时，会在响应头中指定传输的数据类型，例如图片、音频、视频等，以确保数据能够被正确解析和显示。<br><img src="/img/blog/http1/http数据类型.png" alt="http数据类型"><br>此外，为了节省带宽，服务端还可以将数据压缩后再传输，并将压缩方法放到响应头中，这样客户端就可以根据压缩方法解压数据。</p><h3 id="HTTP-1-0多数据格式传输处理的基本流程"><a href="#HTTP-1-0多数据格式传输处理的基本流程" class="headerlink" title="HTTP/1.0多数据格式传输处理的基本流程"></a>HTTP/1.0多数据格式传输处理的基本流程</h3><ul><li>请求报文<br> 第二行：可以接受服务器返回任意类型的文件<br> 第三行：支持服务器采用gzip、deflate、br，其中任意一种压缩方式<br> 第四行：期望返回的文件编码是UTF-8<br> 第五行：期望优先语言是中文<br><img src="/img/blog/http1/http多数据请求报文.png" alt="http多数据请求报文"></li></ul><ul><li>响应报文<br> 第二行：服务器采用了br压缩方式<br> 第三行：服务端返回的是图片类型的文件<br> 有了响应头信息，浏览器就会用br方法来解压文件，在按照图片格式来处理文件<br><img src="/img/blog/http1/http多数据响应报文.png" alt="http多数据响应报文"></li></ul><h3 id="HTTP-1-0缓存机制"><a href="#HTTP-1-0缓存机制" class="headerlink" title="HTTP/1.0缓存机制"></a>HTTP/1.0缓存机制</h3><p>每次客户端请求资源，服务器都会返回完整的响应，即使该资源已经被请求过并且没有发生变化。<br>这种方式会导致网络带宽的浪费，并且增加服务器的负载，因此HTTP/1.0加入缓存机制。<br>如果客户端已经缓存了需要请求的资源，它可以使用缓存版本而不必再次请求服务器。<br><img src="/img/blog/http1/http缓存.png" alt="http缓存"></p><p><strong>涉及到缓存相关的头字段</strong></p><ul><li>Pragma: no-cache不使用缓存数据</li><li>Expires：资源过期时间</li><li>Last-Modified：资源最后修改时间</li><li>If-Modified-Since：验证资源是否过期</li></ul><h3 id="HTTP-1-0缓存策略流程"><a href="#HTTP-1-0缓存策略流程" class="headerlink" title="HTTP/1.0缓存策略流程"></a>HTTP/1.0缓存策略流程</h3><p>初次请求服务器会返回资源，同时会带上资源的过期时间和最后修改时间。<br>当下次请求时，通过比较本地时间和过期时间，判断缓存是否过期，未过期则读取并使用。<br>若检查发现资源已经过期，则带上修改时间重新请求服务器，服务器通过比较资源最后修改时间，判断资源是否变更。<br>若服务器发现资源变更，则返回新资源，未变更则返回状态码304，表示资源可以继续使用。<br><img src="/img/blog/http1/http缓存策略流程.png" alt="http缓存策略流程"></p><h3 id="HTTP-1-0其余特性"><a href="#HTTP-1-0其余特性" class="headerlink" title="HTTP/1.0其余特性"></a>HTTP/1.0其余特性</h3><p>HTTP/1.0还依据当时实际需求引入很多其他特性。<br>虚拟主机、状态码、服务代理、用户代理等等。  </p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>由于HTTP/1.0版本没有充分考虑缓存控制、持久化连接的需求，于是在1997年发布HTTP/1.1版本</p><h3 id="HTTP-1-1持久连接"><a href="#HTTP-1-1持久连接" class="headerlink" title="HTTP/1.1持久连接"></a>HTTP/1.1持久连接</h3><p>如果在请求index.html的页面含有其他资源，比如style.css、jquery.js等。<br>每个资源都需要通过单独的HTTP请求来获取，这就需要频繁创建和销毁TCP连接，增加通信双方负载，同时也损耗传输性能。<br><img src="/img/blog/http1/http持久化连接1.png" alt="http持久化连接1"></p><p><strong>HTTP/1.1引入了持久连接的机制，也称为HTTP keep-alive或者HTTP连接重用</strong><br>在一个持久连接中，客户端发送一个请求，服务器响应后不会立即关闭连接，而是继续保持连接，等待客户端发送下一个请求。<br>这样客户端和服务器在同一个TCP连接上，可以传输多个请求和响应，避免频繁创建和销毁TCP连接，从而提高传输效率。<br><img src="/img/blog/http1/http持久化连接2.png" alt="http持久化连接2"></p><h3 id="HTTP-1-1管道机制"><a href="#HTTP-1-1管道机制" class="headerlink" title="HTTP/1.1管道机制"></a>HTTP/1.1管道机制</h3><p>尽管通过持久连接机制，可以重用TCP连接来提高传输性能。<br>但是在同一个TCP连接上，每个请求必须等到前一个请求的响应之后才能发送，这就会导致在页面中请求多个资源时传输效率低下。<br><strong>为了解决这个问题HTTP/1.1引入管道机制</strong><br>它允许客户端在同一个TCP连接上，同时发送多个请求，而无需等待前一个请求的响应，以此来充分利用等待响应过程中的时间。<br><img src="/img/blog/http1/http管道机制.png" alt="http管道机制"></p><p>但是因为HTTP是文本协议，请求和响应之间没有序号标识关联，服务器只能收到请求的顺序逐一处理，然后依次响应。<br>如果其中一个请求非常耗时，或者因为某些原因没有及时响应，后面其他请求就会被阻塞，存在队头阻塞的问题。<br>此外管道机制稳定性差，而且存在兼容性问题，现在浏览器默认都关闭管道化，大部分服务器默认不支持管道化。<br><img src="/img/blog/http1/http管道化弊端.png" alt="http管道化弊端"></p><h3 id="HTTP-1-1TCP并发连接"><a href="#HTTP-1-1TCP并发连接" class="headerlink" title="HTTP/1.1TCP并发连接"></a>HTTP/1.1TCP并发连接</h3><p>为了提高网页加载速度，浏览器通常会在同一个域名下建立多个TCP连接，这样可以使用多个连接，同时下载网页中的资源。<br>但是过多连接可能会导致网络拥塞，同一域名下的并发连接数，一般限制在6个左右。<br><img src="/img/blog/http1/http_TCP并发连接.png" alt="http_TCP并发连接"></p><h3 id="HTTP-1-1缓存策略"><a href="#HTTP-1-1缓存策略" class="headerlink" title="HTTP/1.1缓存策略"></a>HTTP/1.1缓存策略</h3><h4 id="HTTP-1-0缓存策略的问题"><a href="#HTTP-1-0缓存策略的问题" class="headerlink" title="HTTP/1.0缓存策略的问题"></a>HTTP/1.0缓存策略的问题</h4><ul><li>通过绝对时间比较本地时间和Expries，由于本地时间不一定可靠，缓存过期判断不一定准确。  </li><li>使用资源最后修改时间，作为判断资源是否变更，这个方式存在问题，比如资源在一段时间内经常修改，实际内容可能没有变化，可以继续使用缓存。  </li></ul><p>针对以上问题，HTTP/1.1缓存头字段新增以下几个字段</p><ul><li>Cache-Control：控制缓存行为</li><li>ETag：资源的Hash值</li><li>If-None-Match：验证资源是否变更<br><img src="/img/blog/http1/http缓存字段.png" alt="http缓存字段"></li></ul><h4 id="HTTP-1-1缓存策略改进以下3点"><a href="#HTTP-1-1缓存策略改进以下3点" class="headerlink" title="HTTP/1.1缓存策略改进以下3点"></a>HTTP/1.1缓存策略改进以下3点</h4><ul><li>使用相对时间max-age，代替绝对时间Expires，避免判断缓存过期时，本地时间不可靠的问题</li><li>Cache-Control使得缓存控制的机制更加灵活</li><li>验证资源有效，除了验证最后修改时间，还可以通过ETag作更准确的判断<br><img src="/img/blog/http1/http缓存策略改进.png" alt="http缓存策略改进"></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTP协议经历多个版本的演变，每个版本都引入新的特性和功能，使得HTTP协议称为一种通用的应用层协议。  </p><p>HTTP协议不断适应互联网发展需求，通过引入新的技术和机制，成为现代互联网应用的基础协议之一。<br><img src="/img/blog/http1/http发展流程.png" alt="http发展流程"></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解HTTP协议及其通信过程</title>
      <link href="/2023/07/07/HTTP/"/>
      <url>/2023/07/07/HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="理解HTTP协议及其通信过程"><a href="#理解HTTP协议及其通信过程" class="headerlink" title="理解HTTP协议及其通信过程"></a>理解HTTP协议及其通信过程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HTTP（HyperText Transfer Protocol）全称超文本传输协议，它是一种支持传输各种格式的数据资源（如图片、音频、视频等）的协议。它起源于Web的诞生，是Web通信的基础协议。</p><h2 id="HTTP的组成"><a href="#HTTP的组成" class="headerlink" title="HTTP的组成"></a>HTTP的组成</h2><p>HTTP由三部分组成，分别是超文本（HyperText）、传输（Transfer）和协议（Protocol）。</p><ul><li>超文本：指的是包含超链接的文本，这些超链接可以指向其他文本或资源。<br><img src="/img/blog/http/hyper_text.png" alt="hyper_text"></li><li>传输：指的是通过HTTP协议将数据资源从服务器传输到客户端。<br><img src="/img/blog/http/transfer.png" alt="transfer"></li><li>协议：指的是通信双方为了交换信息而使用的一种规定格式和规则的约定。</li></ul><h2 id="HTTP的通信过程"><a href="#HTTP的通信过程" class="headerlink" title="HTTP的通信过程"></a>HTTP的通信过程</h2><p>一次HTTP请求过程可以分为四个阶段：建立TCP连接、发送请求、响应请求和关闭TCP连接。</p><ol><li><p>建立TCP连接：在通信过程中，首先需要建立TCP连接。这是通过握手的方式进行，握手过程中，客户端和服务器交换数据以确认彼此的身份。</p></li><li><p>发送请求：一旦TCP连接建立成功，客户端可以发送HTTP请求。请求由四部分组成，包括请求行、请求头、空行和消息体。请求行包含请求方法(GET、POST等)、请求目标资源(URL)和协议版本。请求头则以键值对的形式表示特定的信息。</p></li><li><p>响应请求：服务器收到请求后，解析并准备相应的数据，然后按照HTTP协议规定发送响应报文。响应报文由四部分组成，包括状态行、响应头、空行和消息体。状态行包含协议版本、状态码和原因。响应头与请求头类似，也是以键值对的形式表示特定的信息。</p></li><li><p>关闭TCP连接：响应完成后，可以关闭TCP连接以释放资源。<br><img src="/img/blog/http/http请求过程.png" alt="http请求过程"></p></li></ol><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>TCP报文下方是HTTP报文，HTTP协议是基于TCP协议的应用层协议，请求和响应都是通过TCP协议进行传输<br><img src="/img/blog/http/tcp报文.png" alt="tcp报文"></p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>一旦TCP连接建立成功，客户端就可以发送HTTP请求了。请求由多部分组成，包括请求行、请求头、空行和消息体。</p><ul><li>请求行：包含请求方法（GET、POST等）、请求目标资源（URL）和协议版本。</li><li>请求头：用键值对的形式表示，以回车换行符作为结束符。</li><li>空行：请求头之后是一个空行。</li><li>消息体：如果请求需要携带数据，就会包含在消息体中。<br><img src="/img/blog/http/http请求报文.png" alt="http请求报文"></li></ul><h3 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h3><p>服务器收到请求后，会解析请求报文，准备相应的数据，并通过HTTP协议约定发送响应报文。响应报文也由多部分组成，包括状态行、响应头、空行和消息体。</p><ul><li>状态行：包含协议版本、状态码（用数字表示处理结果，如200表示成功，500表示服务器错误）和原因（对状态码的解释）。</li><li>响应头：与请求头类似，以键值对的形式表示。</li><li>空行：响应头之后是一个空行。</li><li>消息体：根据请求的需要，服务器可能会返回一些数据，它们包含在消息体中。<br><img src="/img/blog/http/http响应报文.png" alt="http响应报文"></li></ul><h2 id="通信双方之间的数据传递"><a href="#通信双方之间的数据传递" class="headerlink" title="通信双方之间的数据传递"></a>通信双方之间的数据传递</h2><p>通过HTTP协议，浏览器将用户输入的网址转换为请求报文发送给服务器。服务器按照协议规定解析报文并准备数据，然后按照规定发送响应报文。浏览器接收响应报文后解析报文并呈现数据。<br><img src="/img/blog/http/http协议全过程.png" alt="http协议全过程"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTP是一个简单的请求响应协议，它定义了客户端可能发送给服务器的消息和服务器可能返回给客户端的响应。</p><p>它的通信过程包括建立TCP连接、发送请求、响应请求和关闭TCP连接四个阶段。</p><p>通过HTTP协议，客户端和服务器可以进行数据传输，实现Web通信。  </p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LangChain中的ChatOpenAI类与OpenAI类的区别</title>
      <link href="/2023/07/06/ChatOpenAI%E4%B8%8EOpenAI/"/>
      <url>/2023/07/06/ChatOpenAI%E4%B8%8EOpenAI/</url>
      
        <content type="html"><![CDATA[<h1 id="LangChain中的ChatOpenAI类与OpenAI类的区别"><a href="#LangChain中的ChatOpenAI类与OpenAI类的区别" class="headerlink" title="LangChain中的ChatOpenAI类与OpenAI类的区别"></a>LangChain中的ChatOpenAI类与OpenAI类的区别</h1><p>LangChain是一个AI框架，允许开发者使用ChatOpenAI类和OpenAI类来实现不同的功能。<br>在本文中，我们将讨论这两个类的区别以及它们在LangChain的使用中的不同场景。</p><h2 id="ChatOpenAI类和OpenAI类的区别"><a href="#ChatOpenAI类和OpenAI类的区别" class="headerlink" title="ChatOpenAI类和OpenAI类的区别"></a>ChatOpenAI类和OpenAI类的区别</h2><p>从LangChain API官网文档中我们可以看到，ChatOpenAI类属于langchain.chat_models模块，而OpenAI类属于langchain模块。它们之间的主要区别在于适用的场景和API功能。<br><a href="https://python.langchain.com/docs/modules/agents/agent_types/openai_functions_agent.html">LangChain API官网</a><br><img src="/img/blog/chat_open_ai/langchain_api.png" alt="langchain_api"></p><h3 id="ChatOpenAI类"><a href="#ChatOpenAI类" class="headerlink" title="ChatOpenAI类"></a>ChatOpenAI类</h3><p>ChatOpenAI类用于处理聊天会话场景，并支持LangChain中的聊天模型。<br><img src="/img/blog/chat_open_ai/chat_openai_support_models.png" alt="chat_openai_support_models"><br>当我们想要实现人类与AI之间多轮的对话和交互时，可以使用ChatOpenAI类。<br>该类的使用需要传递使用LangChain框架封装的消息类SystemMessage。<br><img src="/img/blog/chat_open_ai/chat_openai_implenment.png" alt="chat_openai_implenment"></p><h3 id="OpenAI类"><a href="#OpenAI类" class="headerlink" title="OpenAI类"></a>OpenAI类</h3><p>OpenAI类则适用于一问一答的场景，并且没有聊天会话的概念。<br>OpenAI类支持的模型包括较老的模型，如davinci等。<br><img src="/img/blog/chat_open_ai/openai_support_models.png" alt="openai_support_models"><br>该类可以直接实例化，而不需要特定的消息类。<br><img src="/img/blog/chat_open_ai/openai_implenment.png" alt="openai_implenment"></p><h2 id="API文档和功能"><a href="#API文档和功能" class="headerlink" title="API文档和功能"></a>API文档和功能</h2><p>在OpenAI API官网上，我们可以找到有关Chat和Completions两个概念的详细信息。</p><h3 id="Chat"><a href="#Chat" class="headerlink" title="Chat"></a>Chat</h3><p>Chat功能用于给定一个由对话组成的消息列表，模型将返回一个响应。<br>Chat API endpoint:<code>https://api.openai.com/v1/chat/completions</code><br>重点关注聊天会话。<br><a href="https://platform.openai.com/docs/api-reference/chat">OpenAI Chat API官网</a><br><img src="/img/blog/chat_open_ai/chat_api.png" alt="chat_api">  </p><h3 id="Completions"><a href="#Completions" class="headerlink" title="Completions"></a>Completions</h3><p>Completions功能用于给定一个提示（prompt），模型将返回一个或多个预测的补全结果，并可以返回每个位置的可选标记概率。需要注意的是，OpenAI建议大多数用户使用Chat Completions API。<br>Completions API endpoint:<code>https://api.openai.com/v1/completions</code><br>重点关注一问一答场景，而没有聊天会话的概念。<br><a href="https://platform.openai.com/docs/api-reference/completions">OpenAI Completions API官网</a><br><img src="/img/blog/chat_open_ai/completions_api.png" alt="completions_api">  </p><p>综上所述，ChatOpenAI适用于聊天模型，适用于多轮问答交互场景；而OpenAI则适用于较老的模型，如davinci等。</p>]]></content>
      
      
      <categories>
          
          <category> AI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半监督学习及其处理方法</title>
      <link href="/2023/07/03/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/03/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="半监督学习及其处理方法"><a href="#半监督学习及其处理方法" class="headerlink" title="半监督学习及其处理方法"></a>半监督学习及其处理方法</h1><h2 id="半监督学习的定义"><a href="#半监督学习的定义" class="headerlink" title="半监督学习的定义"></a>半监督学习的定义</h2><p>标注数据和图像通常是机器学习中成本最高的部分，因此在有限的标注数据的情况下，利用大量无标注数据来训练模型是很有吸引力的。这就是半监督学习的核心思想，其中少量有标注数据与大量无标注数据相结合。</p><h2 id="半监督学习的三个假设"><a href="#半监督学习的三个假设" class="headerlink" title="半监督学习的三个假设"></a>半监督学习的三个假设</h2><h3 id="连续性、平滑性假设"><a href="#连续性、平滑性假设" class="headerlink" title="连续性、平滑性假设"></a>连续性、平滑性假设</h3><p>连续性、平滑性假设认为相近的数据点可能具有相同的标签。根据这一假设，我们可以通过学习到的特征对数据点进行分类。</p><p><img src="/img/blog/Semi-supervised/连续性、平滑性假设.png" alt="连续性、平滑性假设"></p><h3 id="集群假设"><a href="#集群假设" class="headerlink" title="集群假设"></a>集群假设</h3><p>集群假设认为数据在高维空间中往往被组织成高密度的集群。同一集群的数据点可能具有相同的标签。因此，模型的决策边界应该位于密集的数据点区域之间，将它们分离成不连续的群组。</p><p><img src="/img/blog/Semi-supervised/集群假设.png" alt="集群假设"></p><h3 id="流形假设"><a href="#流形假设" class="headerlink" title="流形假设"></a>流形假设</h3><p>流形假设认为高维数据分布可以在一个嵌入式的低维空间中表示。这个低维空间被称为数据流形，通过在流形空间中进行学习，可以更好地利用数据的结构信息。</p><h4 id="集群假设和连续性假设被认为是相对可靠的，并且我们可以根据学到的表征来对一个数据点进行分类。"><a href="#集群假设和连续性假设被认为是相对可靠的，并且我们可以根据学到的表征来对一个数据点进行分类。" class="headerlink" title="集群假设和连续性假设被认为是相对可靠的，并且我们可以根据学到的表征来对一个数据点进行分类。"></a>集群假设和连续性假设被认为是相对可靠的，并且我们可以根据学到的表征来对一个数据点进行分类。</h4><h2 id="半监督学习的处理方法"><a href="#半监督学习的处理方法" class="headerlink" title="半监督学习的处理方法"></a>半监督学习的处理方法</h2><h3 id="一致性正则化-Consistency-Regularization"><a href="#一致性正则化-Consistency-Regularization" class="headerlink" title="一致性正则化(Consistency Regularization)"></a>一致性正则化(Consistency Regularization)</h3><p>一致性正则化的核心动机是利用连续性和集群假设。它的具体操作是对于一个给定的特征x，模型应该对潜在Augment(x)半径内的所有数据点做出类似的预测。这样，即使数据增强导致输入发生微小变化，模型的输出仍然保持一致。</p><p><img src="/img/blog/Semi-supervised/加扰动不影响输出.png" alt="加扰动不影响输出"></p><h4 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h4><ul><li>Semi-Supervised Semantic Segmentation with Cross-Consistency Training<br><img src="/img/blog/Semi-supervised/一致性正则化1.png" alt="一致性正则化1"></li></ul><hr><ul><li>Semi-Supervised Semantic Segmentation with Directional Context-aware Consistency<br><img src="/img/blog/Semi-supervised/一致性正则化2.png" alt="一致性正则化2"></li></ul><h3 id="伪标签-Pseudo-labeling"><a href="#伪标签-Pseudo-labeling" class="headerlink" title="伪标签(Pseudo-labeling)"></a>伪标签(Pseudo-labeling)</h3><p>伪标签的核心动机是将半监督问题转换成全监督问题。具体操作是通过教师网络或全监督网络预测并生成伪标签。这样，我们可以将无标注数据作为有标注数据来训练模型，从而扩大训练集规模。</p><h4 id="相关论文-1"><a href="#相关论文-1" class="headerlink" title="相关论文"></a>相关论文</h4><ul><li>Semi-Supervised Semantic Segmentation via Adaptive Equalization Learning<br><img src="/img/blog/Semi-supervised/伪标签1.png" alt="伪标签1"></li></ul><hr><ul><li>Semi-Supervised Medical Image Segmentation via Cross Teaching between CNN and Transformer<br><img src="/img/blog/Semi-supervised/伪标签2.png" alt="伪标签2"></li></ul><h3 id="生成对抗网络-Generative-Adversarial-Network"><a href="#生成对抗网络-Generative-Adversarial-Network" class="headerlink" title="生成对抗网络(Generative Adversarial Network)"></a>生成对抗网络(Generative Adversarial Network)</h3><p>生成对抗网络的核心动机是利用鉴别器找到值得信赖的数据区域。通过生成器和鉴别器之间的对抗训练，生成对抗网络可以生成具有高质量的伪标签，并用它们来辅助训练。</p><h4 id="相关论文-2"><a href="#相关论文-2" class="headerlink" title="相关论文"></a>相关论文</h4><ul><li>Adversarial Learning for Semi-Supervised Semantic Segmentation<br><img src="/img/blog/Semi-supervised/生成对抗网络.png" alt="生成对抗网络"></li></ul><h3 id="主动学习-active-learning"><a href="#主动学习-active-learning" class="headerlink" title="主动学习(active learning)"></a>主动学习(active learning)</h3><p>主动学习的核心动机是识别哪些未标记的点是最有价值的，并由人类在循环中对它们进行标记。通过这种方式，可以在有限标注资源的情况下，最大限度地提高模型性能。<br><img src="/img/blog/Semi-supervised/主动学习.png" alt="主动学习"></p><h4 id="相关论文-3"><a href="#相关论文-3" class="headerlink" title="相关论文"></a>相关论文</h4><ul><li>Towards Fewer Annotations: Active Learning via Region Impurity and Prediction Uncertainty for Domain Adaptive Semantic Segmentation</li></ul><p>以上是关于半监督学习的概要内容和常用处理方法。通过充分利用无标注数据，半监督学习可以在有限标注数据的情况下提高模型性</p>]]></content>
      
      
      <categories>
          
          <category> AI学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Semi-supervised </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Airflow Metadata Database</title>
      <link href="/2023/02/01/airflow_metadata_database/"/>
      <url>/2023/02/01/airflow_metadata_database/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近打算读取和修改Airflow metadata DB数据，完成用户权限管理，还有获取Airflow dags tasks运行信息<br>后来修改Airflow API设置，发现2.2.4版本stable rest API功能很多，上面需求基本上可以通过call API完成<br>既然花时间了解Airflow metadata table，干脆写个文章记录下<br><strong><em>本文章只针对Airflow 2.2.4版本，转载请注明来自 <a href="https://nerovv.github.io/">Nero Blog</a>！</em></strong>  </p><h2 id="Airflow基本介绍"><a href="#Airflow基本介绍" class="headerlink" title="Airflow基本介绍"></a>Airflow基本介绍</h2><p>Airflow基础概念: <strong><a href="https://airflow.apache.org/docs/apache-airflow/2.2.4/concepts/index.html">Airflow Concepts</a></strong><br>Airflow概述: <strong><a href="https://airflow.apache.org/docs/apache-airflow/2.2.4/concepts/overview.html">Airflow Overview</a></strong><br>Airflow官方网站提到: 了解Airflow DB架构主要帮助排查故障和学习，<strong>不建议直接访问或者修改DB数据</strong></p><blockquote><p>It might be changed at any time and you should not directly access the database to retrieve information from it or modify the data - you should use REST API Reference to do that instead. The main purpose of this diagram is to help with troubleshooting and understanding of the internal Airflow DB architecture in case you have any problems with the database - for example when dealing with problems with migrations</p></blockquote><h2 id="Airflow-tables-缓慢更新ing…"><a href="#Airflow-tables-缓慢更新ing…" class="headerlink" title="Airflow tables (缓慢更新ing…)"></a>Airflow tables (缓慢更新ing…)</h2><p>ab_permission</p><details class="folding-tag" cyan="">  <summary>ab_permission</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">name</td>    <td align="center">VARCHAR(100)</td>    <td align="center">NOT NULL</td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_permission.png" style="float: left"><br><br><br><br><br>   <p>ab_permission记录9种基础action</p>  <ol>   <li>can_read</li>     <li>can_edit</li>     <li>can_delete</li>    <li>can_create</li>     <li>menu_access</li>   <li>can_list</li>     <li>can_show</li>     <li>can_get</li>     <li>can_test</li>    </ol>    <a href="https://airflow.apache.org/docs/apache-airflow/2.2.4/security/access-control.html?highlight=access%20control#resource-based-permissions">Airflow Resource-Based permissions</a>  <p>Permissions (each consistent of a resource + action pair) are then added to roles.</p> </div>   </details><p>ab_permission_view</p><details class="folding-tag" cyan="">  <summary>ab_permission_view</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">permission_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">view_menu_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_permission_view.png" style="float: left"><br><br><br><br><br><br>  ab_permission_view记录Airflow现有permission组合<br>  Permission是由resource(permission_id) + action(view_menu_id)组合而成<br>  因此ab_permission和ab_view_menu 2个表，是ab_permission_view关联表<br>  <img src="/img/blog/airflow_db/ab_permission_view_relationship.png">  跟dag权限相关的资源   <ol>     <li>DAG Runs</li>       <li>Task Instances</li>       <li>DAG Code</li>      <li>Task Logs</li>       <li>Website</li>     <li>Task Reschedules</li>   </ol>  </div></details><p>ab_permission_view_role </p><details class="folding-tag" cyan="">  <summary>ab_permission_view_role</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">permission_view_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">role_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_permission_view_role.png" style="float: left">  <br><br><br><br><br><br>  ab_permission_view_role记录permission和role的关联关系<br>  role和permission的关系是一对多，如表格所示<br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">id</th>    <th align="center">permission_view_id</th>    <th align="center">role_id</th>   </tr>   <tr>    <td align="center">1</td>    <td align="center">14</td>    <td align="center">3</td>   <tr>    <td align="center">2</td>    <td align="center">5</td>    <td align="center">3</td>   </tr>   <tr>    <td align="center">3</td>    <td align="center">38</td>    <td align="center">3</td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_permission_view_role_relationship.png">  </div></details> <p>ab_register_user</p><details class="folding-tag" cyan="">  <summary>ab_register_user</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">email</td>    <td align="center">VARCHAR(256)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">first_name</td>    <td align="center">VARCHAR(64)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">last_name</td>    <td align="center">VARCHAR(64)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">password</td>    <td align="center">VARCHAR(256)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">registration_date</td>    <td align="center">DATETIME</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">registration_hash</td>    <td align="center">VARCHAR(256)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">username</td>    <td align="center">VARCHAR(256)</td>    <td align="center">NOT NULL</td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_register_user.png" style="float: left">  <br><br><br><br><br><br><br><br><br><br><br><br>  ab_register_user记录Airflow注册用户信息<br>  </div></details><p>ab_role </p><details class="folding-tag" cyan="">  <summary>ab_role</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">name</td>    <td align="center">VARCHAR(64)</td>    <td align="center">NOT NULL</td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_role.png" style="float: left">  <br><br><br><br><br>  ab_role记录Airflow现有的role<br>  Airflow自带的role有5个<br>   <ol>    <li>Admin</li>      <li>Public</li>      <li>Viewer</li>     <li>User</li>      <li>Op</li>   </ol> </div>  </details><p>ab_user</p><details class="folding-tag" cyan="">  <summary>ab_user</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">active</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">changed_by_fk</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">changed_on</td>    <td align="center">DATETIME</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">created_by_fk</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">created_on</td>    <td align="center">DATETIME</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">email</td>    <td align="center">VARCHAR(256)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">fail_login_count</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">first_name</td>    <td align="center">VARCHAR(64)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">last_login</td>    <td align="center">DATETIME</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">last_name</td>    <td align="center">VARCHAR(64)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">login_count</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">password</td>    <td align="center">VARCHAR(256)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">username</td>    <td align="center">VARCHAR(256)</td>    <td align="center">NOT NULL</td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_user.png" style="float: left">  <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>  ab_user记录Airflow用户信息<br>  其中包括用户基本资料、登录时间、登录失败次数...<br>  <b><i>修改或删除用户API和command中，会用username识别用户，在创建用户时要保证username的唯一性</i></b><br> </div> </details><p>ab_user_role </p><details class="folding-tag" cyan="">  <summary>ab_user_role</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">role_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">user_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_user_role.png" style="float: left">  <br><br><br><br><br><br>  ab_user_role记录user和role的关联关系<br>  user和role的关系是一对多，如表格所示<br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">id</th>    <th align="center">role_id</th>    <th align="center">user_id</th>   </tr>   <tr>    <td align="center">1</td>    <td align="center">2</td>    <td align="center">3</td>   <tr>    <td align="center">2</td>    <td align="center">1</td>    <td align="center">3</td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_user_role_relationship.png">  </div></details>  <p>ab_view_menu   </p><details class="folding-tag" cyan="">  <summary>ab_view_menu</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">name</td>    <td align="center">VARCHAR(250)</td>    <td align="center">NOT NULL</td>   </tr>  </table>  <img src="/img/blog/airflow_db/ab_view_menu.png" style="float: left"><br><br><br><br><br>  ab_view_menu记录52种Airflow resource<br>  每当新建一个dag，会创建新资源DAG:{dag_id}<br>   <ol>    <li>Connections</li>      <li>DAGs</li>      <li>DAGs Runs</li>     <li>Task Instances</li>      <li>Audit Logs</li>    <li>ImportError</li>      <li>Pools</li>      <li>Providers</li>      <li>Variables</li>      <li>XComs</li>      <li>DAG Code</li>      <li>Configurations</li>      <li>Plugins</li>      <li>Roles</li>      <li>Permissions</li>      <li>Users</li>      <li>DAG Dependencies</li>      <li>Jobs</li>      <li>My Password</li>      <li>My Profile</li>      <li>SLA Misses</li>      <li>Task Logs</li>      <li>Website</li>      <li>Browse</li>      <li>Documentation</li>      <li>Docs</li>      <li>Admin</li>      <li>Task Reschedules</li>      <li>Triggers</li>      <li>Password</li>      <li>IndexView</li>      <li>UtilView</li>      <li>LocaleView</li>      <li>SecurityApi</li>      <li>AuthLDAPView</li>      <li>CustomUserLDAPModelView</li>      <li>List Users</li>      <li>Security</li>      <li>List Roles</li>      <li>User Stats Chart</li>      <li>User's Statistics</li>      <li>RegisterUserModelView</li>      <li>Base Permissions</li>      <li>View Menus</li>      <li>Views/Menus</li>      <li>Permission Views</li>      <li>Permission on Views/Menus</li>      <li>MenuApi</li>      <li>AutocompleteView</li>      <li>Airflow</li>      <li>DagDependenciesView</li>      <li>RedocView</li>     </ol>    </div></details><p>alembic_version </p><details class="folding-tag" cyan="">  <summary>alembic_version</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">version_num</td>    <td align="center">VARCHAR(32)</td>    <td align="center">NOT NULL</td>  </table>  <img src="/img/blog/airflow_db/alembic_version.png" style="float: left">  <br><br><br><br><br><br>  </div></details>  <p>connection  </p><details class="folding-tag" cyan="">  <summary>connection</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">conn_id</td>    <td align="center">VARCHAR(250)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">conn_type</td>    <td align="center">VARCHAR(500)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">description</td>    <td align="center">VARCHAR(5000)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">extra</td>    <td align="center">TEXTT</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">host</td>    <td align="center">VARCHAR(5000)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">is_encrypted</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">is_encrypted_encrypted</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">login</td>    <td align="center">VARCHAR(5000)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">password</td>    <td align="center">VARCHAR(5000)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">port</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">schema</td>    <td align="center">VARCHAR(5000)</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/connection.png" style="float: left">  <br><br><br><br><br><br>  </div></details>  <p>dag  </p><details class="folding-tag" cyan="">  <summary>dag</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">dag_id</td>    <td align="center">VARCHAR(250)</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">default_view</td>    <td align="center">VARCHAR(250)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">description</td>    <td align="center">TEXT</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">fileloc</td>    <td align="center">VARCHAR(2000)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">has_import_errors</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">has_task_concurrency_limits</td>    <td align="center">BOOLEAN</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">is_active</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">is_paused</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">is_subdag</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">last_expired</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">last_parsed_time</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">last_pickled</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">max_active_runs</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">max_active_tasks</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">next_dagrun</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">next_dagrun_create_after</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">next_dagrun_data_interval_end</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">next_dagrun_data_interval_start</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">owners</td>    <td align="center">VARCHAR(2000)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">pickle_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">processor_subdir</td>    <td align="center">VARCHAR(2000)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">root_dag_id</td>    <td align="center">VARCHAR(250)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">schedule_interval</td>    <td align="center">TEXT</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">scheduler_lock</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">timetable_description</td>    <td align="center">VARCHAR(1000)</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/dag.png" style="float: left">  <br><br><br><br><br><br>  </div></details>  <p>dag_code  </p><details class="folding-tag" cyan="">  <summary>dag_code</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">fileloc_hash</td>    <td align="center">BIGINT</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">fileloc</td>    <td align="center">VARCHAR(2000)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">last_updated</td>    <td align="center">TIMESTAMP</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">source_code</td>    <td align="center">TEXT</td>    <td align="center">NOT NULL</td>   </tr>  </table>  <img src="/img/blog/airflow_db/dag_code.png" style="float: left">  <br><br><br><br><br><br>  </div></details>  <p>dag_pickle  </p><details class="folding-tag" cyan="">  <summary>dag_pickle</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">created_dttm</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">pickle</td>    <td align="center">BLOB</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">pickle_hash</td>    <td align="center">BIGINT</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/dag_pickle.png" style="float: left">  <br><br><br><br><br><br>  </div></details> <p>dag_run  </p><details class="folding-tag" cyan="">  <summary>dag_run</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">conf</td>    <td align="center">BLOB</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">creating_job_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">dag_hash</td>    <td align="center">VARCHAR(32)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">dag_id</td>    <td align="center">VARCHAR(250)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">data_interval_end</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">data_interval_start</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">end_date</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">execution_date</td>    <td align="center">TIMESTAMP</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">external_trigger</td>    <td align="center">BOOLEAN</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">last_scheduling_decision</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">log_template_id</td>    <td align="center">INTEGER</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">queued_at</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">run_id</td>    <td align="center">VARCHAR(250)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">run_type</td>    <td align="center">VARCHAR(50)</td>    <td align="center">NOT NULL</td>   </tr>   <tr>    <td align="center">start_date</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">state</td>    <td align="center">VARCHAR(50)</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/dag_run.png" style="float: left">  <br><br><br><br><br><br>  </div></details> <p>dag_tag  </p><details class="folding-tag" cyan="">  <summary>dag_tag</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">dag_id</td>    <td align="center">VARCHAR(250)</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">name</td>    <td align="center">VARCHAR(100)</td>    <td align="center">NOT NULL</td>   </tr>  </table>  <img src="/img/blog/airflow_db/dag_tag.png" style="float: left">  <br><br><br><br><br><br>  </div></details> <p>import_error  </p><details class="folding-tag" cyan="">  <summary>import_error</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">filename</td>    <td align="center">VARCHAR(1024)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">stacktrace</td>    <td align="center">TEXT</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">timestamp</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/import_error.png" style="float: left">  <br><br><br><br><br><br>  </div></details> <p>job  </p><details class="folding-tag" cyan="">  <summary>job</summary> <div class="content">  <br>  <table border="1px" cellspacing="0" align="center">   <tr>    <th align="center">Columns</th>    <th align="center">Data type</th>    <th align="center">NULL</th>   </tr>   <tr>    <td align="center">id</td>    <td align="center">INTEGER</td>    <td align="center">NOT NULL</td>   <tr>    <td align="center">dag_id</td>    <td align="center">VARCHAR(250)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">end_date</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">executor_class</td>    <td align="center">VARCHAR(500)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">hostname</td>    <td align="center">VARCHAR(500)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">job_type</td>    <td align="center">VARCHAR(30)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">latest_heartbeat</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">start_date</td>    <td align="center">TIMESTAMP</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">state</td>    <td align="center">VARCHAR(20)</td>    <td align="center"></td>   </tr>   <tr>    <td align="center">unixname</td>    <td align="center">VARCHAR(1000)</td>    <td align="center"></td>   </tr>  </table>  <img src="/img/blog/airflow_db/job.png" style="float: left">  <br><br><br><br><br><br><br><br><br><br><br><br><br><br>  </div></details> <p>log<br>rendered_task_instance_fields<br>sensor_instance<br>serialized_dag<br>session<br>sla_miss<br>slot_pool<br>task_fail<br>task_instance<br>task_reschedule<br>test_pg_connection<br>trigger<br>variable<br>xcom  </p><!-- 参考文档 https://chenzuoli.github.io/2021/10/28/airflow%E5%85%83%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AF%A6%E8%A7%A3/ https://chenzuoli.github.io/2021/11/13/Airflow%E5%85%83%E6%95%B0%E6%8D%AE%E8%A1%A8dag%E4%BB%8B%E7%BB%8D/ https://airflow.apache.org/docs/apache-airflow/2.4.0/database-erd-ref.html https://airflow.apache.org/docs/apache-airflow/2.2.4/_api/airflow/models/ https://airflow.apache.org/docs/apache-airflow/2.2.4/security/access-control.html?highlight=access%20control#resource-based-permissions https://docs.astronomer.io/learn/airflow-database markdown https://markdown.com.cn/extended-syntax/tables.html https://markdown.com.cn/basic-syntax/lists.html -->]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> airflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip index versions</title>
      <link href="/2023/01/12/pip_inedex_versions/"/>
      <url>/2023/01/12/pip_inedex_versions/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><em>本文以安装pylibmc为例</em></strong><br>公司私有的nexus仓库，package version相比公有nexus仓库会少一些<br>在pip install pylibmc之前，会用pip install pylibmc==先查询nexus仓库有那些version  </p><h2 id="pip-install-pylibmc-带来的问题"><a href="#pip-install-pylibmc-带来的问题" class="headerlink" title="pip install pylibmc== 带来的问题"></a>pip install pylibmc== 带来的问题</h2><p>由于pip下载python package的特性，pip install pylibmc== 不指定version情况下，有0.0.0 version的package会直接下载，而不是输出Could not find a version的error信息  </p><p>这个问题，虽然可以指定一个不存在的version (pip install pylibmc==blork)来解决，但是pip官方有提到，这种error信息输出是实验性质，21.1以后的version会有改动  </p><blockquote><p>Note that this command is experimental, and might change in the future!  </p></blockquote><p>因此依赖Could not find a version这个error信息，获取package version不是一个最好的解决方案    </p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>pip version &lt;= 20.3只能使用pip install pylibmc==blork，从error信息获取一个package所有version  </p><p>pip version &gt;= 21.2就能用pip index versions pylibmc的标准输出，获取一个package的version  </p><p>个人建议，尽量把pip升级到&gt;=21.2，用pip index versions command获取package version信息  </p><p>解决方案参考: <strong><a href="https://stackoverflow.com/questions/4888027/python-and-pip-list-all-versions-of-a-package-thats-available">Python and pip, list all versions of a package that’s available?</a></strong>   </p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建命令</title>
      <link href="/2022/12/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/12/22/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-命令行"><a href="#hexo-命令行" class="headerlink" title="hexo 命令行"></a>hexo 命令行</h2><h3 id="下载butterfly主题命令"><a href="#下载butterfly主题命令" class="headerlink" title="下载butterfly主题命令"></a>下载butterfly主题命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br><span class="line">npm update hexo-theme-butterfly</span><br></pre></td></tr></table></figure><h3 id="下载hexo插件命令"><a href="#下载hexo插件命令" class="headerlink" title="下载hexo插件命令"></a>下载hexo插件命令</h3><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点击查看命令    </button><div class="hide-content"><h4 id="pug以及stylus的渲染器"><a href="#pug以及stylus的渲染器" class="headerlink" title="pug以及stylus的渲染器"></a>pug以及stylus的渲染器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h4 id="静态代码挂载到GitHub"><a href="#静态代码挂载到GitHub" class="headerlink" title="静态代码挂载到GitHub"></a>静态代码挂载到GitHub</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="本地搜索系统"><a href="#本地搜索系统" class="headerlink" title="本地搜索系统"></a>本地搜索系统</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h4 id="文章字数统计"><a href="#文章字数统计" class="headerlink" title="文章字数统计"></a>文章字数统计</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h4 id="lived2d框架和模型"><a href="#lived2d框架和模型" class="headerlink" title="lived2d框架和模型"></a>lived2d框架和模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install --save live2d-widget-model-wanko</span><br></pre></td></tr></table></figure><h4 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-envelope --save</span><br></pre></td></tr></table></figure><h4 id="页脚GitHub徽标"><a href="#页脚GitHub徽标" class="headerlink" title="页脚GitHub徽标"></a>页脚GitHub徽标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-footer-beautify --save</span><br></pre></td></tr></table></figure><h4 id="分类磁贴"><a href="#分类磁贴" class="headerlink" title="分类磁贴"></a>分类磁贴</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-magnet --save</span><br></pre></td></tr></table></figure><h4 id="文章置顶栏"><a href="#文章置顶栏" class="headerlink" title="文章置顶栏"></a>文章置顶栏</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-swiper --save</span><br></pre></td></tr></table></figure><h4 id="主题文章双栏布局"><a href="#主题文章双栏布局" class="headerlink" title="主题文章双栏布局"></a>主题文章双栏布局</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-butterfly-article-double-row --save</span><br></pre></td></tr></table></figure><h4 id="wowjs动画"><a href="#wowjs动画" class="headerlink" title="wowjs动画"></a>wowjs动画</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-wowjs --save</span><br></pre></td></tr></table></figure><h4 id="电子时钟"><a href="#电子时钟" class="headerlink" title="电子时钟"></a>电子时钟</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-butterfly-clock</span><br><span class="line">npm install hexo-butterfly-clock-anzhiyu --save</span><br><span class="line">npm install hexo-butterfly-tag-plugins-plus --save</span><br></pre></td></tr></table></figure><h4 id="外挂标签"><a href="#外挂标签" class="headerlink" title="外挂标签"></a>外挂标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><h4 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure></div></div><h3 id="部署和本地启动命令"><a href="#部署和本地启动命令" class="headerlink" title="部署和本地启动命令"></a>部署和本地启动命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br><span class="line">hexo cl &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h2 id="部分外挂标签展示"><a href="#部分外挂标签展示" class="headerlink" title="部分外挂标签展示"></a>部分外挂标签展示</h2><h3 id="上标标签-tip"><a href="#上标标签-tip" class="headerlink" title="上标标签 tip"></a>上标标签 tip</h3><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><h3 id="时间轴样式"><a href="#时间轴样式" class="headerlink" title="时间轴样式"></a>时间轴样式</h3><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><p>2022-07-24时间模块</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>2022-05-15时间模块</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2022-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><p>2022-04-20时间模块</p></div></div></div><h2 id="b站视频适配"><a href="#b站视频适配" class="headerlink" title="b站视频适配"></a>b站视频适配</h2><div align=center class="aspect-ratio">    <iframe src="//player.bilibili.com/player.html?aid=330784383&bvid=BV1SA411s7iK&cid=273046680&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>     scrolling="no"     border="0"     frameborder="no"     framespacing="0"     high_quality=1    danmaku=1     allowfullscreen="true">     </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 博客改造 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
